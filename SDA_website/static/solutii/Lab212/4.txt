<pre id="0" onclick="afisare(0)">
Problem2<br><br><br>Idee de rezolvare:<br><br>Initial, avem doua liste: shuffled_data si data. Trebuie sa ordonam elementele din shuffled_data in ordinea pe care o au in data. Pentru simplitate, prima coada va fi numita in continuare Q1, iar a doua coada Q2. Introducem elementele din shuffled_data in Q1, si parcurgem lista data cu un contor, verificand la fiecare pas daca elementul curent din data este egal cu front-ul lui Q1; daca da, il eliminam din Q1 si il punem in vectorul de solutii si trecem la urmatorul element din data; daca nu, il eliminam din Q1 si il adaugam in Q2, la final. Repetam aceeasi pasi pentru Q2: comparam front-ul lui Q2 cu elementul curent din data, daca sunt egale, scoatem elementul din Q2, il punem in vectorul de solutii si trecem la urmatorul element din data; daca nu, scoatem elementul din Q2 si il adaugam la final in Q1. Pentru optimizare, putem incepe algoritmul dupa adaugarea primului element in coada Q1, nu este nevoie sa adaugam intai toate elementele pentru ca algoritmul sa functioneze, insa avem nevoie de verificari suplimentare pentru a nu adauga/sterge elemente inexistente(nule) din cozi.<br><br>Secventa finala este: e 1 x 1 s I_1 g 1 l 1 h 1 y 1 o I_1 z I_1 d 1 2 1 2 1 2 1 2 1 2 I_2 I_1 I_2 2 I_2 1 2 I_2 I_1 I_2 <br><strike>e</strike> <strike>x</strike> <strike>s</strike> <strike>g</strike> <strike>l</strike> <strike>h</strike> <strike>y</strike> <strike>o</strike> <strike>z</strike> <strike>d</strike> <strike>e</strike> <strike>x</strike> <strike>g</strike> <strike>l</strike> <strike>h</strike> <strike>e</strike> <strike>g</strike> <br><strike>e</strike> <strike>x</strike> <strike>g</strike> <strike>l</strike> <strike>h</strike> <strike>y</strike> <strike>d</strike> <strike>e</strike> <strike>x</strike> <strike>g</strike> <strike>l</strike> <strike>e</strike> <br></pre><pre id="1" onclick="afisare(1)">
Problem3<br>Idee de rezolvare: Selectam primul element din vectorul b. Luam fiecare element din vectorul a si il introducem in stiva.<br>Cat timp stiva nu este goala si ultimul element din stiva este egal cu elementul curent din b, atunci il scoatem, afisam p si trecem mai departe in b.<br>	Adaugam 5 la operatii si adaugam elementul 5 in stiva<br><table border=1><tr><td>5</td></tr></table><br>	Adaugam p la operatii si scoatem elementul 5 din stiva<br><table border=1><tr><td><strike>5</strike> </td></tr></table><br>	Adaugam 4 la operatii si adaugam elementul 4 in stiva<br><table border=1><tr><td>4</td></tr></table><br>	Adaugam 1 la operatii si adaugam elementul 1 in stiva<br><table border=1><tr><td>4</td><td>1</td></tr></table><br>	Adaugam 6 la operatii si adaugam elementul 6 in stiva<br><table border=1><tr><td>4</td><td>1</td><td>6</td></tr></table><br>	Adaugam 3 la operatii si adaugam elementul 3 in stiva<br><table border=1><tr><td>4</td><td>1</td><td>6</td><td>3</td></tr></table><br>	Adaugam 9 la operatii si adaugam elementul 9 in stiva<br><table border=1><tr><td>4</td><td>1</td><td>6</td><td>3</td><td>9</td></tr></table><br>	Adaugam 2 la operatii si adaugam elementul 2 in stiva<br><table border=1><tr><td>4</td><td>1</td><td>6</td><td>3</td><td>9</td><td>2</td></tr></table><br>	Adaugam 8 la operatii si adaugam elementul 8 in stiva<br><table border=1><tr><td>4</td><td>1</td><td>6</td><td>3</td><td>9</td><td>2</td><td>8</td></tr></table><br>	Adaugam p la operatii si scoatem elementul 8 din stiva<br><table border=1><tr><td>4</td><td>1</td><td>6</td><td>3</td><td>9</td><td>2</td><td><strike>8</strike> </td></tr></table><br>	Adaugam 7 la operatii si adaugam elementul 7 in stiva<br><table border=1><tr><td>4</td><td>1</td><td>6</td><td>3</td><td>9</td><td>2</td><td>7</td></tr></table><br>Nu se poate</pre><pre id="2" onclick="afisare(2)">
Problem4<br>Idee de rezolvare: Mutam elementele din stiva in prima coada pana la elementul cautat, pe care il  stergem. Mutam elem. din prima coada in cealalta pana cand in prima coada ramane un singur element,pe care il adaugam in stiva. Repetam procedeul pentru fiecare coada alternativ, pana cand acestea devin vide si astfel elementele sunt adaugate in ordinea corecta in stiva<br><br>Stiva este: [6, 8, 9, 1, 10, 2, 3, 5]<br>Rezolvare: Mutam elementele din stiva in coada 1, pana gasim elementul de sters, adica 8<br>P: Mutam elementul 5 in coada 1<br>P: Mutam elementul 3 in coada 1<br>P: Mutam elementul 2 in coada 1<br>P: Mutam elementul 10 in coada 1<br>P: Mutam elementul 1 in coada 1<br>P: Mutam elementul 9 in coada 1<br>S: Stergem elementul 8 din stiva<br><br>Stiva devine: [6], prima coada devine: [5, 3, 2, 10, 1, 9] a doua coada devine []<br><br>Mutam cate un element din coada nevida in coada vida pana cand in coada din care se face extragerea ramane un singur el.,pe care il adaugam in stiva:<br>1: Mutam din coada 1 elem. 5 in coada 2<br>1: Mutam din coada 1 elem. 3 in coada 2<br>1: Mutam din coada 1 elem. 2 in coada 2<br>1: Mutam din coada 1 elem. 10 in coada 2<br>1: Mutam din coada 1 elem. 1 in coada 2<br>I_1: Stergem elementul 9 din coada 1 si apoi il adaugam in stiva<br><br>Stiva devine: [6, 9], prima coada devine: [], a doua coada devine: [5, 3, 2, 10, 1]<br><br>2: Mutam din coada 2 elem 5 in coada 1<br>2: Mutam din coada 2 elem 3 in coada 1<br>2: Mutam din coada 2 elem 2 in coada 1<br>2: Mutam din coada 2 elem 10 in coada 1<br>I_2: Stergem elementul 1 din coada 2 si apoi il adaugam in stiva<br><br>Stiva devine[6, 9, 1], prima coada devine:[5, 3, 2, 10], a doua coada devine:[]<br>1: Mutam din coada 1 elem. 5 in coada 2<br>1: Mutam din coada 1 elem. 3 in coada 2<br>1: Mutam din coada 1 elem. 2 in coada 2<br>I_1: Stergem elementul 10 din coada 1 si apoi il adaugam in stiva<br><br>Stiva devine: [6, 9, 1, 10], prima coada devine: [], a doua coada devine: [5, 3, 2]<br><br>2: Mutam din coada 2 elem 5 in coada 1<br>2: Mutam din coada 2 elem 3 in coada 1<br>I_2: Stergem elementul 2 din coada 2 si apoi il adaugam in stiva<br><br>Stiva devine[6, 9, 1, 10, 2], prima coada devine:[5, 3], a doua coada devine:[]<br>1: Mutam din coada 1 elem. 5 in coada 2<br>I_1: Stergem elementul 3 din coada 1 si apoi il adaugam in stiva<br><br>Stiva devine: [6, 9, 1, 10, 2, 3], prima coada devine: [], a doua coada devine: [5]<br><br>I_2: Stergem elementul 5 din coada 2 si apoi il adaugam in stiva<br><br>Stiva devine[6, 9, 1, 10, 2, 3, 5], prima coada devine:[], a doua coada devine:[]<br>Succesiunea operatiilor este: P, P, P, P, P, P, S, 1, 1, 1, 1, 1, I_1, 2, 2, 2, 2, I_2, 1, 1, 1, I_1, 2, 2, I_2, 1, I_1, I_2<br></pre><pre id="3" onclick="afisare(3)">
Problem5<br>1. Inserati urmatoarele valori, pe rand, intr-un arbore binar de cautare: [14, 85, 34, 78, 44, 56, 93, 66, 97, 66, 81, 49, 70, 12, 44, 93, 84, 73, 25, 93, 47, 38, 54, 86, 5, 34, 72, 6, 38]<br>2. Scrieti nodurile care se pot sterge in doua moduri. <br>3. Stergeti elementul: 38<br>Idee de rezolvare: Vom insera elemente in arbore folosind o functie prin recurenta care<br>        returneaza radacina arborelui, deoarece avem nevoie de referinta. Stergerea unui element se va face <br>        in functie de caz: daca are 0, 1 sau 2 copii. In primele 2 cazuri gasim parintele, cu ajutorul <br>        functiei parent, iar apoi mutam referinta nodului parintelui la None, respectiv la copilul <br>        nodului. In al treilea caz, cautam nodul cu care nodul nostru va fi inlocuit cu ajutorul <br>        functiei minValue(care ia cel mai mic nod din dreapta), punem valoarea in nodul curent, apoi<br>        stergem nodul cu care am inlocuit. Elementele care pot fi sterse in 2 moduri sunt cele care au 2 copii,<br>        iar acestea vor fi gasite cu ajutorul functiilor children(calculeaza numarul de copii) si morechildren<br>        (gaseste nodurile care au 2 copii)<br>ELementele arborelui in inordine sunt: [6, 5, 12, 25, 38, 47, 54, 49, 72, 73, 70, 66, 56, 44, 84, 81, 78, 34, 86, 97, 93, 85, 14]<br>ELementele arborelui in preordine sunt: [14, 12, 5, 6, 85, 34, 25, 78, 44, 38, 56, 49, 47, 54, 66, 70, 73, 72, 81, 84, 93, 86, 97]<br>Elementele care se pot sterge in 2 moduri sunt: [14, 34, 44, 49, 56, 78, 85, 93]<br>Elementul care trebuie sters este: 38<br>Arborele, din care s-a sters 38: [14, 12, 5, 6, 85, 34, 25, 78, 44, 38, 81, 84, 93, 86, 97]</pre><pre id="4" onclick="afisare(4)">
Problem7<br>Reconstruim arborele si facem parcurgerile:<br>Parcurgerea SRD a arborelui binar creat este:[46, 4, 49, 21, 32]<br>Parcurgerea RSD a arborelui binar creat este:[21, 4, 46, 49, 32]<br>Parcurgerea SDR a arborelui binar creat este: [46, 49, 4, 32, 21]<br></pre><pre id="5" onclick="afisare(5)">
Problem9<br>9. Solutia problemei: <br>1. A/F ca [58, 11, 15, 79, 39, 42] rezulta din 3 pasi de Selection Sort (Maxim) : <br>11 < 58<br>15 > 11 => (FALS) <br><br> 2. A/F ca [58, 11, 15, 79, 39, 42] rezulta din 2 pasi de Insertion Sort : <br>11 < 58 => (FALS) <br><br>3. A/F partitionat pentru Quicksort cu pivotul 79 <br>i. Pozitia pivotului = 4<br>ii. Vf. elementele de la stanga sunt mai mici <br>58 <= 79<br>11 <= 79<br>15 <= 79<br>iii. Vf elementele de la dreapta mai mari<br>39 <= 79 => (FALS) <br><br>4. Exemplificam Bubble sort: <br>i.Vectorul are 6 elemente <br>ii.Cat timp facem interschimbari = > nu am terminat <br>0: [58, 11, 15, 79, 39, 42]<br>1: [11, 15, 58, 39, 42, 79]<br>2: [11, 15, 39, 42, 58, 79]<br><br>5.Exemplificam Selection Sort(Maxim): <br>i.Vectorul are 6 elemente <br>0: [58, 11, 15, 79, 39, 42]<br>1: [79, 11, 15, 58, 39, 42]<br>2: [79, 58, 15, 11, 39, 42]<br>3: [79, 58, 42, 11, 39, 15]<br>4: [79, 58, 42, 39, 11, 15]<br>5: [79, 58, 42, 39, 15, 11]<br><br></pre><pre id="6" onclick="afisare(6)">
Problem10<br>Pentru toate cazurile generam submultimi de elemente din vector pentru a cauta-o pe aceea care <br>are numarul minim de elemente pe care sa le putem sterge pentru a satisface fiecare cerinta.<br>Generarea submultimilor se face prin selectia combinarilor de n elemente luate cate nrPasi <br>corespunzator subpunctului.<br>La fiecare pas din cerinta iteram prin combinarile genrate si le alegem pe cele care au o<br>lungime corespunzatoarenumarului de pasi pe care l-a facut altgoritmul si sunt sortate<br><br>a)Selectia maximului.<br><br>Pentru selectia maximului am gasit 35 subseturi de lungime 2 : [7, 8] [7, 11] [7, 10] [7, 9] [3, 8] [3, 11] [3, 4] [3, 10] [3, 6] [3, 5] [3, 9] [1, 8] [1, 2] [1, 11] [1, 4] [1, 10] [1, 6] [1, 5] [1, 9] [8, 11] [8, 10] [8, 9] [2, 11] [2, 4] [2, 10] [2, 6] [2, 5] [2, 9] [4, 10] [4, 6] [4, 5] [4, 9] [6, 9] [5, 9] [0, 9] <br>Aceste subseturi au lungimea egala cu numarul de pasi(2) pentru acest subpunct, din cerinta.<br><br>La fiecare pas consideram secventa sortata  s1, ..., sP, unde P e lungimea secventei, si eliminam numerele:<br>	- care sunt mai mari decat sP<br>	- care sunt mai mici decat s1 si se afla dupa s1 in vector<br>	- care sunt mai mici decat sP si se afla dupa sP in vector<br>	- care apartin intervalului [s1, sP], dar nu sunt in secventa<br><br>Pentru secventa [7, 8] elementele [ 3 1 2 11 4 10 6 5 0 9 ] au fost sterse conform celor de mai sus.<br>Pentru secventa [7, 11] elementele [ 3 1 8 2 4 10 6 5 0 9 ] au fost sterse conform celor de mai sus.<br>...<br><br>RASPUNS: Secventa minima pe care o stergem este de lungime 6 => stergem: [7 8 11 10 5 0] <br><br>b)Selectia minimului:<br><br>Pentru selectia minimului am gasit 35 subseturi de lungime 2 : [7, 8] [7, 11] [7, 10] [7, 9] [3, 8] [3, 11] [3, 4] [3, 10] [3, 6] [3, 5] [3, 9] [1, 8] [1, 2] [1, 11] [1, 4] [1, 10] [1, 6] [1, 5] [1, 9] [8, 11] [8, 10] [8, 9] [2, 11] [2, 4] [2, 10] [2, 6] [2, 5] [2, 9] [4, 10] [4, 6] [4, 5] [4, 9] [6, 9] [5, 9] [0, 9] <br>Aceste subseturi au lungimea egala cu numarul de pasi(2) pentru acest subpunct, din cerinta.<br><br>La fiecare pas consideram secventa sortata  s1, ..., sP, unde P e lungimea secventei, si eliminam numerele:<br>	- care sunt mai mici decat s1<br>	- care sunt mai mari decat sP si se afla la stanga lui sP<br>	- care apartin intervalului [s1, sP] dar nu se afla un subset<br><br>Pentru secventa [7, 8] elementele [ 3 1 2 11 4 10 6 5 0 9 ] au fost sterse conform celor de mai sus.<br>Pentru secventa [7, 11] elementele [ 3 1 8 2 4 10 6 5 0 9 ] au fost sterse conform celor de mai sus.<br>...<br><br>RASPUNS: Secventa minima pe care o stergem este de lungime 6 => stergem: [7 8 11 10 5 0] <br><br>c)Insertie:<br><br>Pentru insertie am gasit 35 subseturi care respecta cerinta : [7, 8, 11] [7, 8, 10] [7, 8, 9] [3, 8, 11] [3, 8, 10] [3, 8, 9] [3, 4, 10] [3, 4, 6] [3, 4, 5] [3, 4, 9] [3, 6, 9] [3, 5, 9] [1, 8, 11] [1, 8, 10] [1, 8, 9] [1, 2, 11] [1, 2, 4] [1, 2, 10] [1, 2, 6] [1, 2, 5] [1, 2, 9] [1, 4, 10] [1, 4, 6] [1, 4, 5] [1, 4, 9] [1, 6, 9] [1, 5, 9] [2, 4, 10] [2, 4, 6] [2, 4, 5] [2, 4, 9] [2, 6, 9] [2, 5, 9] [4, 6, 9] [4, 5, 9] <br>Aceste subseturi au lungimea egala cu numarul de pasi+1(2+1=3) pentru acest subpunct, din cerinta.<br><br>La fiecare pas consideram secventa sortata  s1, ..., sP, unde P e lungimea secventei, si eliminam numerele:<br>	- care sunt mai mici decat s1<br>	- care sunt mai mari decat sP<br>	- care apartin intervalului [s1, sP] dar nu se afla un subset<br><br>Pentru secventa [7, 8, 11] elementele [ 3 1 2 ] au fost sterse conform celor de mai sus.<br>Pentru secventa [7, 8, 10] elementele [ 3 1 2 11 4 ] au fost sterse conform celor de mai sus.<br>...<br><br>RASPUNS: Secventa minima pe care o stergem este de lungime 3 => stergem: [3 1 2] </pre><pre id="7" onclick="afisare(7)">
Problem11<br>Idee de rezolvare:<br>Partitionarea Lomuto are ca scop alegerea unui element dintr-un vector de numere, care se va numi<br>pivot si modificarea pozitiilor elementelor din vector astfel incat, la finalul algoritmului,<br>elementele cu valoare mai mica decat pivotul se vor afla la stanga sa, iar cele mai mari decat<br>pivotul, in dreapta acestuia, pivotul ajungand pe pozitia in care ar sta daca am sorta vectorul.<br><br>Interschimbam 23 cu 23 iar i devine 0<br>Sirul devine:[23, 56, 66, 6, 86, 49]<br><br>Interschimbam 6 cu 56 iar i devine 1<br>Sirul devine:[23, 6, 66, 56, 86, 49]<br><br>Trecem la urmatorul element din sir.<br>Am ajuns la capatul sirului. In final, avem vectorul partitionat: [23, 6, 49, 56, 86, 66]</pre>