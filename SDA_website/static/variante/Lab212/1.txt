<br><pre id="0" onclick="afisare(0)"><br><br>Problem2<br><br><br>Problema 2 - 2C:<br><br>Aveti la dispozitie 2 cozi. Introduceti elementele  v o j w i m d e in aceasta ordine, obtinand la final  j w i d o m e v.<br><br>Operatii: <br><br> 'caracter' -> se introduce caracterul in prima coada <br><br>1 -> se scoate din prima coada si se introduce in a doua coada <br><br>2 -> se scoate din a doua coada si se introduce in prima coada <br><br>I_1 se extrage un element din coada 1 si se afiseaza <br><br>I_2 se extrage un element din coada 2 si se afiseaza <br><br><br></pre><br><pre id="1" onclick="afisare(1)"><br><br>Problem3<br>1. Sa se gaseasca o succesiune de mutari astfel incat introducant elementele:  [6, 2, 5, 1, 3, 4] in stiva, la final sa se afiseze: [6, 2, 4, 3, 1, 5]<br>Pentru rezolvare avem nevoie de operatiile: <br>    'n'-> inserarea numarului in stiva<br>    'p'-> extragerea unui numar din stiva si afisarea<br><br></pre><br><pre id="2" onclick="afisare(2)"><br><br>Problem4<br>SS. Avand stiva: [5, 7, 8, 10, 3, 6, 9, 1, 2] gasiti o succesiune de mutari a.i. sa stergeti din stiva elementul 10 avand la dispozitie 2 cozi si operatiile:<br>P -> se extrage un el. din stiva, se introduce in prima coada<br>S -> se sterge un element din stiva<br>1 -> se extrage un el. din coada 1 si se introduce in coada 2<br>2 -> se extrage un el. din coada 2 si se introduce in coada 1<br>I_1 -> se extrage un el. din coada 1 si se introduce in stiva<br>I_2 -> se extrage un el. din coada 2 si se introduce in stiva<br><br></pre><br><pre id="3" onclick="afisare(3)"><br><br>Problem5<br>1. Inserati urmatoarele valori, pe rand, intr-un arbore binar de cautare: [42, 68, 53, 39, 26, 93, 45, 29, 30, 38, 48, 25, 62, 80, 58, 51, 82, 41, 94, 96, 24, 58, 61, 72, 92, 48, 94, 38, 37, 92]<br>2. Scrieti nodurile care se pot sterge in doua moduri. <br>3. Stergeti elementul: 92<br></pre><br><pre id="4" onclick="afisare(4)"><br><br>Problem7<br>Problema 7: RA <br>Reconstruiti arborele care are parcurgerile RSD si SRD date si afisati parcurgerea SDR<br><br>Generarea cerintei<br>Pentru a genera aleator doua parcurgeri RSD si SRD corecte, generam aleator un vector din care<br>vom construi un ABC, pentru care vom face parcurgerile SRD si RSD<br>In continuare, ne folosim de dictionar pentru a redenumi elementele din ABC, fiecare nod primind o<br>valoare random si astfel ABC devenind un arbore binar oarecare. Pentru acest arbore vom face parcurgerile<br>SRD si RSD rezolvand problema generarii cerintei<br><br>Idee de rezolvare a problemei:<br>Pornind de la cele 2 parcurgeri vom reconstrui in mod recursiv arborele binar astfel:<br> -vom determina radacina subarborelui curent din parcurgerea in preordine<br> -o vom cauta in parcurgerea in inordine<br> -vom apela recursiv functia pentru a construi intai subarborele stang si apoi cel drept<br>Setul de elemente random din care vom face ABC este: [37, 22, 34, 46, 6, 7]<br>Inseram pe rand fiecare element fiecare element astfel incat in fiecare valoare din subarborele stang < radacina < fiecare valoare din subarborele drept.<br>Inseram in ABC nodul 22<br>Inseram in ABC nodul 34<br>Inseram in ABC nodul 46<br>Inseram in ABC nodul 6<br>Inseram in ABC nodul 7<br>Parcurgerea SRD a ABC este:<br>[6, 7, 22, 34, 37, 46]<br>Parcurgerea RSD a ABC este:<br>[37, 22, 6, 7, 34, 46]<br>Redenumirea nodurilor in cele dou parcurgeri este:<br>{37: 38, 22: 41, 6: 45, 7: 1, 34: 13, 46: 42}<br>Dupa redenumirea nodurilor parcurgerea finala RSD este:<br>[38, 41, 45, 1, 13, 42]<br>Dupa redenumirea nodurilor parcurgerea finala SRD este:<br>[45, 1, 41, 13, 38, 42]<br><br></pre><br><pre id="5" onclick="afisare(5)"><br><br>Problem8<br>8. Primiti sirul: [85, 5, 94, 9, 2, 64, 11, 24, 73, 26]. Rezolvati urmatoarele cerinte:<br>	- aplicati 2 pasi din alg. de sort. prin insertie urmat de 2 pasi din alg. de sort. prin metoda bulelor;<br>	- aplicati 3 pasi din alg. de sort. prin selectia maximului urmat de 3 pasi din alg. de sort. prin selectia minimului<br>	- ce elemente ar putea fi considerate pivoti a.i. la finalul unei partitionari a alg. Quicksort sa avem primele 3 elemente sortate si specificati partitionarea folosita (Hoare/Lomuto/etc.)<br>	- exemplificati sortarea sirului folosind Insertion Sort si Selection Sort (Minim)<br><br></pre><br><pre id="6" onclick="afisare(6)"><br><br>Problem9<br>Problema 9: Se primesc numerele: 73, 71, 67, 5, 95, 54, 47, 34, 85, 97.<br>Raspundeti cu adevarat sau fals:<br>1. Vectorul a rezultat in urma aplicarii a 3 pasi din Selection Sort (Maxim).<br>2. Vectorul a rezultat in urma aplicarii a 2 pasi din Insertion Sort.<br>3. Vectorul a rezultat in urma unei partitionari folosind pivotul 97.<br>Exemplificati sortarea sirului folosind Bubble Sort si Selection Sort (Maxim).<br><br></pre><br><pre id="7" onclick="afisare(7)"><br><br>Problem10<br>Primind sirul: 7, 9, 5, 10, 1, 0, 2, 4, 11, 8, 3. Gasiti numarul minim de elemente care pot fi sterse<br>a.i. sa se poata considera ca s-au efectuat:<br>a) 4 pasi din alg. de sort. prin selectia max<br>b) 4 pasi din alg. de sort. prin selectia min<br>c) 2 pasi din alg. de sort. prin insertie directa<br><br>=================================================<br></pre><br><pre id="8" onclick="afisare(8)"><br><br>Problem11<br>11. Partitionati Lomuto urmatorul vector: [51, 49, 71, 37, 73, 16, 3, 12, 5] folosind pivotul: 16<br><br></pre><br><pre id="9" onclick="afisare(9)"><br><br>Problem12<br>Problema 12:<br>Reconstruiti un arbore oarecare, primind urmatoarea parcurgere continua in adancime a arborelui,pornind din radacina: 6, 0, 6, 1, 2, 7, 2, 1, 3, 1, 6, 4, 6, 5, 6<br><br></pre><br><pre id="10" onclick="afisare(10)"><br><br>Problem13<br>RAP: Primind parcurgerea in postordine (SDR) a unui arbore binar, reconstruiti arborele<br>SDR: [19, 21, 14, 13, 40, 30, 42, 28]<br><br></pre><br><pre id="11" onclick="afisare(11)"><br><br>Problem13<br>RAP: Primind parcurgerea in postordine (SDR) a unui arbore binar, reconstruiti arborele<br>SDR: [7, 13, 16, 15, 0, 22, 42, 34, 33]<br><br></pre><br><pre id="12" onclick="afisare(12)"><br><br>Problem14<br>Avem secventa:[16, 70, 70, 80, 36, 84, 60, 75, 17, 35, 37, 41, 24, 73, 93, 40, 1, 54, 79, 41]<br> Se va afisa parcurgerea in postordine a arborelui si un exemplu de o secventa care nu poate fi parcurgerea in postordine a unui arbore si un motiv pentru care nu poate fi SDR<br></pre><br><pre id="13" onclick="afisare(13)"><br><br>Problem15<br>Problema 15 (PN): Primind parcurgerea in preordine (RSD) a unui arbore binar care contine NULL daca nu exista nod, reconstruiti arborele<br>RSD: [4, 14, 'N', 'N', 12, 30, 'N', 10, 'N', 'N', 16, 11, 'N', 'N', 'N', 13, 42, 19, 0, 'N', 41, 'N', 'N', 33, 38, 31, 'N', 'N', 'N', 'N', 'N', 'N']<br><br></pre><br><pre id="14" onclick="afisare(14)"><br><br>Problem16<br>Partitionati urmatorul vector, folosind pivotul 4 si partitionarea de la QS pe care o folosim cand avem multe duplicate: [3, 4, 4, 5, 3, 2, 0, 2, 0, 1]<br>Scrieti numarul de interschimbari.<br></pre><br><pre id="15" onclick="afisare(15)"><br><br>Problem17<br>Primiti un sir de numere naturale.<br>Aplicati o partitionare de la QS pentru a gasi care este al k-lea element, daca vectorul ar<br>fi sortat si exemplificati algoritmul.<br>Ex: 14, 7, 9, 2, 3, 5, 8, 10 si k = 3 => v[3] = 5 (daca v ar fi sortat).<br><br>Sirul de numere primit este:[23, 0, 28, 18, 3, 16, 6, 17, 2, 7, 21, 1, 25]<br><br></pre><br><pre id="16" onclick="afisare(16)"><br><br>Problem19<br>19. Construiti un min-heap folosind valorile: [71, 45, 56, 13, 61, 58, 0] . Decapitati heap-ul.<br></pre><br><pre id="17" onclick="afisare(17)"><br><br>Problem22<br>	Cerinta:<br>22. Sa presupunem ca exista un min-heap care contine exact 4 noduri care au prioritatile: [6, 7, 26, 37]<br> Scrieti toate modurile in care puteti insera elementele, astfel incat, la finalul inserarilor, sa aveti un heap diferit.<br></pre><br><pre id="18" onclick="afisare(18)"><br><br>Problem23<br>Problema 23:<br>Primiti vectorul: [8, 7, 5, 4, 0, 9, 10, 1]. <br>Faceti din acest vector un min-ansamblu folosind un numar<br>minim de operatii si demonstrati complexitatea. <br><br></pre><br><pre id="19" onclick="afisare(19)"><br><br>Problem25<br>1. Sa presupunem ca am vrea sa implementam un heap ternal (fiecare nod are 3 fii). <br>2. Introduceti elementele: [97, 34, 29, 99, 9, 88, 15, 24, 3, 41] intr-un max heap ternal si decapitati heap-ul. <br><br></pre><br><pre id="20" onclick="afisare(20)"><br><br>Problem28<br>Primiti numere naturale > 0 si atunci cand primiti 0,<br>trebuie sa afisati valoarea mediana din vector. <br>Valoarea mediana este v[mij] daca v este sortat si len e impar,<br>altfel e (v[mij1] + v[mij2]) / 2 daca e par.<br><br></pre><br><pre id="21" onclick="afisare(21)"><br><br>Problem29<br><br>Primiti 11 numere naturale si atunci cand primiti 0, trebuie sa afisati cele mai mari 3 elemente.<br><br>Sirul primit este: 62 8 2 0 57 67 53 0 45 72 48 87 94<br></pre><br><pre id="22" onclick="afisare(22)"><br><br>Problem30<br>Primiti un sir: a e f e a b . Gasiti numarul minim de litere (si literele) care ar trebui introduse pentru ca sirul sa devina palindrom.<br></pre><br><pre id="23" onclick="afisare(23)"><br><br>Problem31<br>Problema 31:<br>Evaluati expresia in forma postfixata si construiti un arbore pentru aceasta expresie: 9, 7, 2, 6, 5, +, 4, *, +, +, -<br><br></pre><br><pre id="24" onclick="afisare(24)"><br><br>Problem32<br>Un Prim-Min ABC este un arbore cu urmatoarele proprietati:<br>> radacina are valoarea minima din arbore;<br>> fiecare valoare din sub-arborele st. are o valoare mai mica decat orice valoare din subarborele dr;<br>> sub-arborele stang si sub-arborele drept sunt Prim-Min ABC.<br>Primim numarul 10 si Prim-Min ABC-ul dat de lista de copii:<br>	2: 3, 16<br>	3: 10, 11<br>	10: None, None<br>	11: None, 15<br>	15: None, None<br>	16: 19, 25<br>	19: None, None<br>	25: 27, None<br>	27: None, None<br>Cerinta: Decideti daca acesta  apare in acest arbore.<br><br></pre><br><pre id="25" onclick="afisare(25)"><br><br>problem33<br>Avem secventa:[9, 66, 33, 66, 96, 85, 8, 69]<br>Pe baza secventei vom crea un AVL<br>R----66<br>     L----33<br>     |    L----9<br>     |    |    L----8<br>     |    R----66<br>     R----85<br>          L----69<br>          R----96<br><br>Acest arbore va fi dezechilibrat prin rotatii random ale unor noduri alese tot aleatoriu<br>In cazul in care nodul ales nu are un vecin la stanga sau dreapta, rotatiile nu vor avea loc si se va alege alt nod<br><br></pre><br><pre id="26" onclick="afisare(26)"><br><br>Problem37<br>Primiti urmatoarele litere cu ponderi:<br>[('A', 28), ('L', 37), ('M', 17), ('R', 18)]<br>a) Construiti arborele Huffman si afisati codarile literelor<br>b) Care poate fi codarea cuvantului "ALARMA"<br>0011011111010<br>0100011111010<br>0111011111010<br>1001011111010<br>c) Decodati daca se poate:<br>01011111010<br>1111011111010<br>00001111010<br>d) Gasiti si alte cuvinte.<br><br></pre><br><pre id="27" onclick="afisare(27)"><br><br>Problem39<br>Construiti un hash folosind valorile:[27, 72, 71, 61]<br>a). liste simplu inlantuite: h(x) = x % 17<br>b). open adressing (linear probing): h(x, i) = (x + i) % 13<br>c).quadratic probing:h(x, i) = (x + 8*i^2 + 7*i + 1 ) % 13 <br>d).double hashing: h(x, i) = (x % 13 + i * (17-x % 17 )) % 17<br><br></pre><br><pre id="28" onclick="afisare(28)"><br><br>Problem40<br>Primiti urmatorul hash, carea a fost creat folosind adresarea directa - liniara:<br>1    2    3    4    5    6    7    8    9    10    11    12    <br>12   13   None   3   15   16   18   6   None   9   10   11   <br> • in ce ordine ar fi putut fi inserate elementele intr-un hash:<br>A)[18, 3, 15, 10, 6, 12, 13, 16, 11, 9]<br>B)[18, 11, 15, 10, 6, 12, 9, 16, 3, 13]<br>C)[18, 3, 15, 16, 6, 12, 9, 10, 11, 13]<br>D)[18, 3, 15, 10, 6, 12, 9, 16, 11, 13]<br>E)[18, 3, 15, 10, 6, 12, 9, 16, 11, 13]<br> • stergeti elementul 12 din hash.<br></pre><br><pre id="29" onclick="afisare(29)"><br><br>Problem41<br>Primind urmatorul graf, construiti arborele partial de cost minim folosind algoritmul lui Prim cu heap-uri.<br>0:[(2, 14), (3, 7), (4, 12), (5, 14), (6, 13)]<br>1:[(4, 14), (5, 8)]<br>2:[(0, 14), (3, 6), (4, 9)]<br>3:[(0, 7), (2, 6), (5, 10)]<br>4:[(0, 12), (1, 14), (2, 9), (5, 5), (6, 6)]<br>5:[(0, 14), (1, 8), (3, 10), (4, 5)]<br>6:[(0, 13), (4, 6)]<br><img src="/static/solutii/Lab212/GrafProblem41Var1.png"><br></pre><br><pre id="30" onclick="afisare(30)"><br><br>Problem42<br>Primind urmatorul graf, construiti arborele partial de cost minim (Kruskal):<br><br>Lista de muchii:<br>0  2 -> 12<br>0  4 -> 21<br>0  6 -> 4<br>0  8 -> 30<br>1  2 -> 6<br>1  4 -> 3<br>1  6 -> 27<br>2  3 -> 9<br>3  4 -> 9<br>3  5 -> 6<br>3  6 -> 4<br>4  5 -> 5<br>4  7 -> 23<br>4  8 -> 29<br>6  7 -> 2<br><img src="/static/solutii/Lab212/GrafProblem42Var1.png"><br></pre><br><pre id="31" onclick="afisare(31)"><br><br>Problem43<br>43 (DC) Primind urmatorul graf (neorientat):<br>Lista de muchii:<br>['A', 'C', 14]<br>['A', 'D', 1]<br>['B', 'C', 2]<br>['B', 'F', 10]<br>['C', 'D', 6]<br>['C', 'E', 8]<br>['D', 'E', 4]<br>['E', 'G', 13]<br>['F', 'G', 5]<br>Aplicati algoritmul lui Dijkstra (pe heap-uri) pornind din nodul A pentru a gasi distanta minimade la acesta catre oricare alt nod din graf.<br><br></pre>