<br><pre id="0" onclick="afisare(0)"><br><br>Problem2<br><br><br>Problema 2 - 2C:<br><br>Aveti la dispozitie 2 cozi. Introduceti elementele  o s g i m y b q in aceasta ordine, obtinand la final  q m s i o b y g.<br><br>Operatii: <br><br> 'caracter' -> se introduce caracterul in prima coada <br><br>1 -> se scoate din prima coada si se introduce in a doua coada <br><br>2 -> se scoate din a doua coada si se introduce in prima coada <br><br>I_1 se extrage un element din coada 1 si se afiseaza <br><br>I_2 se extrage un element din coada 2 si se afiseaza <br><br><br></pre><br><pre id="1" onclick="afisare(1)"><br><br>Problem3<br>1. Sa se gaseasca o succesiune de mutari astfel incat introducant elementele:  [5, 2, 4, 3, 6, 1, 7, 8] in stiva, la final sa se afiseze: [5, 3, 6, 4, 2, 8, 7, 1]<br>Pentru rezolvare avem nevoie de operatiile: <br>    'n'-> inserarea numarului in stiva<br>    'p'-> extragerea unui numar din stiva si afisarea<br><br></pre><br><pre id="2" onclick="afisare(2)"><br><br>Problem4<br>SS. Avand stiva: [1, 6, 9, 4, 10, 5, 7] gasiti o succesiune de mutari a.i. sa stergeti din stiva elementul 9 avand la dispozitie 2 cozi si operatiile:<br>P -> se extrage un el. din stiva, se introduce in prima coada<br>S -> se sterge un element din stiva<br>1 -> se extrage un el. din coada 1 si se introduce in coada 2<br>2 -> se extrage un el. din coada 2 si se introduce in coada 1<br>I_1 -> se extrage un el. din coada 1 si se introduce in stiva<br>I_2 -> se extrage un el. din coada 2 si se introduce in stiva<br><br></pre><br><pre id="3" onclick="afisare(3)"><br><br>Problem5<br>1. Inserati urmatoarele valori, pe rand, intr-un arbore binar de cautare: [67, 71, 57, 52, 72, 35, 68, 37, 50, 68, 94, 69, 15, 21, 15]<br>2. Scrieti nodurile care se pot sterge in doua moduri. <br>3. Stergeti elementul: 15<br></pre><br><pre id="4" onclick="afisare(4)"><br><br>Problem7<br>Problema 7: RA <br>Reconstruiti arborele care are parcurgerile RSD si SRD date si afisati parcurgerea SDR<br><br>Generarea cerintei<br>Pentru a genera aleator doua parcurgeri RSD si SRD corecte, generam aleator un vector din care<br>vom construi un ABC, pentru care vom face parcurgerile SRD si RSD<br>In continuare, ne folosim de dictionar pentru a redenumi elementele din ABC, fiecare nod primind o<br>valoare random si astfel ABC devenind un arbore binar oarecare. Pentru acest arbore vom face parcurgerile<br>SRD si RSD rezolvand problema generarii cerintei<br><br>Idee de rezolvare a problemei:<br>Pornind de la cele 2 parcurgeri vom reconstrui in mod recursiv arborele binar astfel:<br> -vom determina radacina subarborelui curent din parcurgerea in preordine<br> -o vom cauta in parcurgerea in inordine<br> -vom apela recursiv functia pentru a construi intai subarborele stang si apoi cel drept<br>Setul de elemente random din care vom face ABC este: [42, 32, 21, 33, 24]<br>Inseram pe rand fiecare element fiecare element astfel incat in fiecare valoare din subarborele stang < radacina < fiecare valoare din subarborele drept.<br>Inseram in ABC nodul 32<br>Inseram in ABC nodul 21<br>Inseram in ABC nodul 33<br>Inseram in ABC nodul 24<br>Parcurgerea SRD a ABC este:<br>[21, 24, 32, 33, 42]<br>Parcurgerea RSD a ABC este:<br>[42, 32, 21, 24, 33]<br>Redenumirea nodurilor in cele dou parcurgeri este:<br>{42: 22, 32: 15, 21: 48, 24: 3, 33: 44}<br>Dupa redenumirea nodurilor parcurgerea finala RSD este:<br>[22, 15, 48, 3, 44]<br>Dupa redenumirea nodurilor parcurgerea finala SRD este:<br>[48, 3, 15, 44, 22]<br><br></pre><br><pre id="5" onclick="afisare(5)"><br><br>Problem8<br>8. Primiti sirul: [51, 33, 80, 3, 1, 28, 50, 52]. Rezolvati urmatoarele cerinte:<br>	- aplicati 4 pasi din alg. de sort. prin insertie urmat de 3 pasi din alg. de sort. prin metoda bulelor;<br>	- aplicati 2 pasi din alg. de sort. prin selectia maximului urmat de 2 pasi din alg. de sort. prin selectia minimului<br>	- ce elemente ar putea fi considerate pivoti a.i. la finalul unei partitionari a alg. Quicksort sa avem primele 3 elemente sortate si specificati partitionarea folosita (Hoare/Lomuto/etc.)<br>	- exemplificati sortarea sirului folosind Insertion Sort si Selection Sort (Minim)<br><br></pre><br><pre id="6" onclick="afisare(6)"><br><br>Problem9<br>Problema 9: Se primesc numerele: 51, 55, 63, 67, 96, 93, 58, 19, 20, 9.<br>Raspundeti cu adevarat sau fals:<br>1. Vectorul a rezultat in urma aplicarii a 4 pasi din Selection Sort (Maxim).<br>2. Vectorul a rezultat in urma aplicarii a 4 pasi din Insertion Sort.<br>3. Vectorul a rezultat in urma unei partitionari folosind pivotul 51.<br>Exemplificati sortarea sirului folosind Bubble Sort si Selection Sort (Maxim).<br><br></pre><br><pre id="7" onclick="afisare(7)"><br><br>Problem10<br>Primind sirul: 10, 4, 1, 2, 11, 7, 3, 5, 9, 8, 6, 0. Gasiti numarul minim de elemente care pot fi sterse<br>a.i. sa se poata considera ca s-au efectuat:<br>a) 2 pasi din alg. de sort. prin selectia max<br>b) 4 pasi din alg. de sort. prin selectia min<br>c) 3 pasi din alg. de sort. prin insertie directa<br><br>=================================================<br></pre><br><pre id="8" onclick="afisare(8)"><br><br>Problem11<br>11. Partitionati Lomuto urmatorul vector: [8, 82, 57, 58, 49, 46] folosind pivotul: 58<br><br></pre><br><pre id="9" onclick="afisare(9)"><br><br>Problem12<br>Problema 12:<br>Reconstruiti un arbore oarecare, primind urmatoarea parcurgere continua in adancime a arborelui,pornind din radacina: 4, 7, 2, 3, 1, 0, 1, 3, 6, 3, 2, 5, 2, 9, 2, 7, 4, 8, 4<br><br></pre><br><pre id="10" onclick="afisare(10)"><br><br>Problem13<br>RAP: Primind parcurgerea in postordine (SDR) a unui arbore binar, reconstruiti arborele<br>SDR: [3, 8, 6, 12, 45, 42, 33, 9]<br><br></pre><br><pre id="11" onclick="afisare(11)"><br><br>Problem13<br>RAP: Primind parcurgerea in postordine (SDR) a unui arbore binar, reconstruiti arborele<br>SDR: [3, 7, 27, 40, 37, 45, 35, 19, 11]<br><br></pre><br><pre id="12" onclick="afisare(12)"><br><br>Problem14<br>Avem secventa:[48, 2, 81, 61, 95, 58, 80, 31, 36, 7, 9, 48, 82, 62, 20, 3, 76, 73, 47, 27]<br> Se va afisa parcurgerea in postordine a arborelui si un exemplu de o secventa care nu poate fi parcurgerea in postordine a unui arbore si un motiv pentru care nu poate fi SDR<br></pre><br><pre id="13" onclick="afisare(13)"><br><br>Problem15<br>Problema 15 (PN): Primind parcurgerea in preordine (RSD) a unui arbore binar care contine NULL daca nu exista nod, reconstruiti arborele<br>RSD: [16, 18, 22, 'N', 45, 8, 'N', 'N', 5, 'N', 'N', 'N', 23, 'N', 'N', 11, 13, 'N', 35, 28, 'N', 'N', 21, 'N', 10, 'N', 37, 'N', 'N', 40, 'N', 'N']<br><br></pre><br><pre id="14" onclick="afisare(14)"><br><br>Problem16<br>Partitionati urmatorul vector, folosind pivotul 5 si partitionarea de la QS pe care o folosim cand avem multe duplicate: [0, 1, 4, 3, 1, 5, 3, 1, 1, 1]<br>Scrieti numarul de interschimbari.<br></pre><br><pre id="15" onclick="afisare(15)"><br><br>Problem17<br>Primiti un sir de numere naturale.<br>Aplicati o partitionare de la QS pentru a gasi care este al k-lea element, daca vectorul ar<br>fi sortat si exemplificati algoritmul.<br>Ex: 14, 7, 9, 2, 3, 5, 8, 10 si k = 3 => v[3] = 5 (daca v ar fi sortat).<br><br>Sirul de numere primit este:[5, 9, 27, 1, 28, 7, 26, 6]<br><br></pre><br><pre id="16" onclick="afisare(16)"><br><br>Problem19<br>19. Construiti un min-heap folosind valorile: [41, 95, 89, 52, 17, 16, 24, 93, 83, 60, 74] . Decapitati heap-ul.<br></pre><br><pre id="17" onclick="afisare(17)"><br><br>Problem22<br>	Cerinta:<br>22. Sa presupunem ca exista un min-heap care contine exact 5 noduri care au prioritatile: [15, 19, 83, 31, 55]<br> Scrieti toate modurile in care puteti insera elementele, astfel incat, la finalul inserarilor, sa aveti un heap diferit.<br></pre><br><pre id="18" onclick="afisare(18)"><br><br>Problem23<br>Problema 23:<br>Primiti vectorul: [8, 4, 1, 7, 2, 11, 6, 0, 5, 9]. <br>Faceti din acest vector un min-ansamblu folosind un numar<br>minim de operatii si demonstrati complexitatea. <br><br></pre><br><pre id="19" onclick="afisare(19)"><br><br>Problem25<br>1. Sa presupunem ca am vrea sa implementam un heap ternal (fiecare nod are 3 fii). <br>2. Introduceti elementele: [4, 8, 96, 99, 83, 66, 7] intr-un max heap ternal si decapitati heap-ul. <br><br></pre><br><pre id="20" onclick="afisare(20)"><br><br>Problem28<br>Primiti numere naturale > 0 si atunci cand primiti 0,<br>trebuie sa afisati valoarea mediana din vector. <br>Valoarea mediana este v[mij] daca v este sortat si len e impar,<br>altfel e (v[mij1] + v[mij2]) / 2 daca e par.<br><br></pre><br><pre id="21" onclick="afisare(21)"><br><br>Problem29<br><br>Primiti 13 numere naturale si atunci cand primiti 0, trebuie sa afisati cele mai mari 4 elemente.<br><br>Sirul primit este: 69 55 0 51 32 11 88 0 10 91 61 25 16 0 6 78<br></pre><br><pre id="22" onclick="afisare(22)"><br><br>Problem41<br>Primind urmatorul graf, construiti arborele partial de cost minim folosind algoritmul lui Prim cu heap-uri.<br>0:[(1, 47), (2, 38), (3, 41), (4, 20), (6, 23)]<br>1:[(0, 47), (2, 36), (4, 49), (5, 29), (6, 33), (7, 49), (8, 44)]<br>2:[(0, 38), (1, 36), (3, 42), (4, 25), (5, 26), (6, 36)]<br>3:[(0, 41), (2, 42), (4, 29), (5, 41), (7, 22)]<br>4:[(0, 20), (1, 49), (2, 25), (3, 29), (5, 43), (7, 37)]<br>5:[(1, 29), (2, 26), (3, 41), (4, 43), (6, 22), (7, 45)]<br>6:[(0, 23), (1, 33), (2, 36), (5, 22), (7, 34)]<br>7:[(1, 49), (3, 22), (4, 37), (5, 45), (6, 34), (8, 24)]<br>8:[(1, 44), (7, 24)]<br><img src="/static/solutii/Lab212/GrafVar5.png"><br></pre>