<pre id="0" onclick="afisare(0)"><br><br>Problem2<br><br><br>Idee de rezolvare:<br><br>Initial, avem doua liste: shuffled_data si data. Trebuie sa ordonam elementele din shuffled_data in ordinea pe care o au in data. Pentru simplitate, prima coada va fi numita in continuare Q1, iar a doua coada Q2. Introducem elementele din shuffled_data in Q1, si parcurgem lista data cu un contor, verificand la fiecare pas daca elementul curent din data este egal cu front-ul lui Q1; daca da, il eliminam din Q1 si il punem in vectorul de solutii si trecem la urmatorul element din data; daca nu, il eliminam din Q1 si il adaugam in Q2, la final. Repetam aceeasi pasi pentru Q2: comparam front-ul lui Q2 cu elementul curent din data, daca sunt egale, scoatem elementul din Q2, il punem in vectorul de solutii si trecem la urmatorul element din data; daca nu, scoatem elementul din Q2 si il adaugam la final in Q1. Pentru optimizare, putem incepe algoritmul dupa adaugarea primului element in coada Q1, nu este nevoie sa adaugam intai toate elementele pentru ca algoritmul sa functioneze, insa avem nevoie de verificari suplimentare pentru a nu adauga/sterge elemente inexistente(nule) din cozi.<br><br>Secventa finala este: p 1 y I_1 e 1 z 1 x I_1 s 1 b I_1 2 I_2 I_1 I_2 I_2 <br><strike>p</strike> <strike>y</strike> <strike>e</strike> <strike>z</strike> <strike>x</strike> <strike>s</strike> <strike>b</strike> <strike>p</strike> <br><strike>p</strike> <strike>e</strike> <strike>z</strike> <strike>s</strike> <br><br></pre><br><pre id="1" onclick="afisare(1)"><br><br>Problem3<br> Idee de rezolvare: Selectam primul element din vectorul b. Punem elementele din vectorul a in stiva pana gasim un numar egal cu cel selectat din vectorul b.<br>Cat timp stiva nu este goala si ultimul element din stiva este egal cu elementul curent din b, scoatem ultimul element din stiva, afisam p si trecem mai departe in b. <br>Se repeta procedeul pana cand toate elementele lui a au fost introduse in stiva.<br>	Adaugam 6 la operatii si adaugam elementul 6 in stiva<br>	<table border=1><tr><td>6</td></tr></table><br>	Adaugam 1 la operatii si adaugam elementul 1 in stiva<br>	<table border=1><tr><td>6</td><td>1</td></tr></table><br>	Adaugam 3 la operatii si adaugam elementul 3 in stiva<br>	<table border=1><tr><td>6</td><td>1</td><td>3</td></tr></table><br>	Adaugam 5 la operatii si adaugam elementul 5 in stiva<br>	<table border=1><tr><td>6</td><td>1</td><td>3</td><td>5</td></tr></table><br>	Adaugam 2 la operatii si adaugam elementul 2 in stiva<br>	<table border=1><tr><td>6</td><td>1</td><td>3</td><td>5</td><td>2</td></tr></table><br>	Adaugam 4 la operatii si adaugam elementul 4 in stiva<br>	<table border=1><tr><td>6</td><td>1</td><td>3</td><td>5</td><td>2</td><td>4</td></tr></table><br>	Adaugam p la operatii si scoatem elementul 4 din stiva<br>	<table border=1><tr><td>6</td><td>1</td><td>3</td><td>5</td><td>2</td><td><strike>4</strike> </td></tr></table><br>	Adaugam p la operatii si scoatem elementul 2 din stiva<br>	<table border=1><tr><td>6</td><td>1</td><td>3</td><td>5</td><td><strike>2</strike> </td></tr></table><br>	Adaugam p la operatii si scoatem elementul 5 din stiva<br>	<table border=1><tr><td>6</td><td>1</td><td>3</td><td><strike>5</strike> </td></tr></table><br>	Adaugam p la operatii si scoatem elementul 3 din stiva<br>	<table border=1><tr><td>6</td><td>1</td><td><strike>3</strike> </td></tr></table><br>	Adaugam p la operatii si scoatem elementul 1 din stiva<br>	<table border=1><tr><td>6</td><td><strike>1</strike> </td></tr></table><br>	Adaugam p la operatii si scoatem elementul 6 din stiva<br>	<table border=1><tr><td><strike>6</strike> </td></tr></table><br>Operatiile necesare aplicate:<br>6 1 3 5 2 4 p p p p p p <br></pre><br><pre id="2" onclick="afisare(2)"><br><br>Problem4<br>Idee de rezolvare: Mutam elementele din stiva in prima coada pana la elementul cautat, pe care il  stergem. Mutam elem. din prima coada in cealalta pana cand in prima coada ramane un singur element,pe care il adaugam in stiva. Repetam procedeul pentru fiecare coada alternativ, pana cand acestea devin vide si astfel elementele sunt adaugate in ordinea corecta in stiva<br><br>Stiva este: [9, 4, 10, 7, 3, 2, 6]<br>Rezolvare: Mutam elementele din stiva in coada 1, pana gasim elementul de sters, adica 10<br>P: Mutam elementul 6 in coada 1<br>P: Mutam elementul 2 in coada 1<br>P: Mutam elementul 3 in coada 1<br>P: Mutam elementul 7 in coada 1<br>S: Stergem elementul 10 din stiva<br><br>Stiva devine: [9, 4], prima coada devine: [6, 2, 3, 7] a doua coada devine []<br><br>Mutam cate un element din coada nevida in coada vida pana cand in coada din care se face extragerea ramane un singur el.,pe care il adaugam in stiva:<br>1: Mutam din coada 1 elem. 6 in coada 2<br>1: Mutam din coada 1 elem. 2 in coada 2<br>1: Mutam din coada 1 elem. 3 in coada 2<br>I_1: Stergem elementul 7 din coada 1 si apoi il adaugam in stiva<br><br>Stiva devine: [9, 4, 7], prima coada devine: [], a doua coada devine: [6, 2, 3]<br><br>2: Mutam din coada 2 elem 6 in coada 1<br>2: Mutam din coada 2 elem 2 in coada 1<br>I_2: Stergem elementul 3 din coada 2 si apoi il adaugam in stiva<br><br>Stiva devine[9, 4, 7, 3], prima coada devine:[6, 2], a doua coada devine:[]<br>1: Mutam din coada 1 elem. 6 in coada 2<br>I_1: Stergem elementul 2 din coada 1 si apoi il adaugam in stiva<br><br>Stiva devine: [9, 4, 7, 3, 2], prima coada devine: [], a doua coada devine: [6]<br><br>I_2: Stergem elementul 6 din coada 2 si apoi il adaugam in stiva<br><br>Stiva devine[9, 4, 7, 3, 2, 6], prima coada devine:[], a doua coada devine:[]<br>Succesiunea operatiilor este: P, P, P, P, S, 1, 1, 1, I_1, 2, 2, I_2, 1, I_1, I_2<br><br></pre><br><pre id="3" onclick="afisare(3)"><br><br>Problem5<br>1. Inserati urmatoarele valori, pe rand, intr-un arbore binar de cautare: [6, 66, 36, 92, 69, 2, 42, 42, 64, 52, 8, 70, 50, 92, 0, 63, 10, 36, 18, 16, 22, 52, 20, 66, 58, 92]<br>2. Scrieti nodurile care se pot sterge in doua moduri. <br>3. Stergeti elementul: 92<br>Idee de rezolvare: Vom insera elemente in arbore folosind o functie prin recurenta care<br>        returneaza radacina arborelui, deoarece avem nevoie de referinta. Stergerea unui element se va face <br>        in functie de caz: daca are 0, 1 sau 2 copii. In primele 2 cazuri gasim parintele, cu ajutorul <br>        functiei parent, iar apoi mutam referinta nodului parintelui la None, respectiv la copilul <br>        nodului. In al treilea caz, cautam nodul cu care nodul nostru va fi inlocuit cu ajutorul <br>        functiei minValue(care ia cel mai mic nod din dreapta), punem valoarea in nodul curent, apoi<br>        stergem nodul cu care am inlocuit. Elementele care pot fi sterse in 2 moduri sunt cele care au 2 copii,<br>        iar acestea vor fi gasite cu ajutorul functiilor children(calculeaza numarul de copii) si morechildren<br>        (gaseste nodurile care au 2 copii)<br>ELementele arborelui in inordine sunt: [0, 2, 16, 20, 22, 18, 10, 8, 50, 58, 63, 52, 64, 42, 36, 70, 69, 92, 66, 6]<br>ELementele arborelui in preordine sunt: [6, 2, 0, 66, 36, 8, 10, 18, 16, 22, 20, 42, 64, 52, 50, 63, 58, 92, 69, 70]<br>Elementele care se pot sterge in 2 moduri sunt: [6, 18, 36, 52, 66]<br>Elementul care trebuie sters este: 92<br>Arborele, din care s-a sters 92: [6, 2, 0, 66, 36, 8, 10, 18, 16, 22, 20, 42, 64, 52, 50, 63, 58, 69, 70]<br></pre><br><pre id="4" onclick="afisare(4)"><br><br>Problem7<br>Reconstruim arborele si facem parcurgerile:<br>Parcurgerea SRD a arborelui binar creat este:[3, 7, 12, 35, 42, 17]<br>Parcurgerea RSD a arborelui binar creat este:[35, 7, 3, 12, 17, 42]<br>Parcurgerea SDR a arborelui binar creat este: [3, 12, 7, 42, 17, 35]<br><br></pre><br><pre id="5" onclick="afisare(5)"><br><br>Problem8<br>============================= <br><br>a) - Aplicam 4 pasi din Insertion Sort vectorului [58, 48, 70, 80, 45, 13, 86, 6, 22]: <br>	 pasul 1: [48, 58, 70, 80, 45, 13, 86, 6, 22]<br>	 pasul 2: [48, 58, 70, 80, 45, 13, 86, 6, 22]<br>	 pasul 3: [48, 58, 70, 80, 45, 13, 86, 6, 22]<br>	 pasul 4: [45, 48, 58, 70, 80, 13, 86, 6, 22]<br>	 Dupa Selection Sort, vectorul devine: [45, 48, 58, 70, 80, 13, 86, 6, 22] <br><br> - Aplicam 2 pasi din Bubble Sort vectorului [45, 48, 58, 70, 80, 13, 86, 6, 22]: <br>	 pasul 1: [45, 48, 58, 70, 13, 80, 6, 22, 86]<br>	 pasul 2: [45, 48, 58, 13, 70, 6, 22, 80, 86]<br>	 Dupa Bubble Sort, vectorul devine: [45, 48, 58, 13, 70, 6, 22, 80, 86] <br><br>Rezultat: [45, 48, 58, 13, 70, 6, 22, 80, 86]<br><br>============================= <br><br>b) - Aplicam 4 pasi din Maximum Selection Sort vectorului [58, 48, 70, 80, 45, 13, 86, 6, 22]: <br>	 pasul 1:  [58, 48, 70, 80, 45, 13, 86, 6, 22]<br>	 pasul 2:  [58, 48, 70, 80, 45, 13, 22, 6, 86]<br>	 pasul 3:  [58, 48, 70, 6, 45, 13, 22, 80, 86]<br>	 pasul 4:  [58, 48, 22, 6, 45, 13, 70, 80, 86]<br>- Aplicam 3 pasi din Minimum Selection Sort vectorului [58, 13, 22, 6, 45, 48, 70, 80, 86]: <br>	 pasul 1:  [6, 13, 22, 58, 45, 48, 70, 80, 86]<br>	 pasul 2:  [6, 13, 22, 58, 45, 48, 70, 80, 86]<br>	 pasul 3:  [6, 13, 22, 58, 45, 48, 70, 80, 86]<br>	 pasul 4:  [6, 13, 22, 45, 58, 48, 70, 80, 86]<br>Rezultat: [6, 13, 22, 45, 58, 48, 70, 80, 86]<br><br>========================<br><br>c) Aplic partitionare Hoare punand fiecare element al vectorului ca pivot<br> 	 >Aleg 58 drept pivot, vectorul devine: [22, 48, 6, 13, 45, 80, 86, 70, 58]<br>		 *Nu-l putem folosi drept pivot<br>	 >Aleg 48 drept pivot, vectorul devine: [22, 6, 13, 45, 80, 70, 86, 48, 58]<br>		 *Nu-l putem folosi drept pivot<br>	 >Aleg 70 drept pivot, vectorul devine: [58, 48, 22, 6, 45, 13, 86, 80, 70]<br>		 *Nu-l putem folosi drept pivot<br>	 >Aleg 80 drept pivot, vectorul devine: [58, 48, 70, 22, 45, 13, 6, 86, 80]<br>		 *Nu-l putem folosi drept pivot<br>	 >Aleg 45 drept pivot, vectorul devine: [22, 6, 13, 45, 80, 70, 86, 48, 58]<br>		 *Nu-l putem folosi drept pivot<br>	 >Aleg 13 drept pivot, vectorul devine: [6, 13, 70, 80, 45, 48, 86, 58, 22]<br>		*Putem sa-l folosi drept pivot<br>	 >Aleg 86 drept pivot, vectorul devine: [58, 48, 70, 80, 45, 13, 22, 6, 86]<br>		 *Nu-l putem folosi drept pivot<br>	 >Aleg 6 drept pivot, vectorul devine: [6, 48, 70, 80, 45, 13, 86, 58, 22]<br>		*Putem sa-l folosi drept pivot<br>	 >Aleg 22 drept pivot, vectorul devine: [22, 6, 13, 80, 45, 70, 86, 48, 58]<br>		 *Nu-l putem folosi drept pivot<br><br><br>============================= <br><br>d)exemplific Insertion Sort<br>	 pasul 1:  [48, 58, 70, 80, 45, 13, 86, 6, 22] <br>	 pasul 2:  [48, 58, 70, 80, 45, 13, 86, 6, 22] <br>	 pasul 3:  [48, 58, 70, 80, 45, 13, 86, 6, 22] <br>	 pasul 4:  [45, 48, 58, 70, 80, 13, 86, 6, 22] <br>	 pasul 5:  [13, 45, 48, 58, 70, 80, 86, 6, 22] <br>	 pasul 6:  [13, 45, 48, 58, 70, 80, 86, 6, 22] <br>	 pasul 7:  [6, 13, 45, 48, 58, 70, 80, 86, 22] <br>	 pasul 8:  [6, 13, 22, 45, 48, 58, 70, 80, 86] <br>	 Dupa Insertion Sort, vectorul este sortat : [6, 13, 22, 45, 48, 58, 70, 80, 86] <br><br>Exemplific Selection Sort (minim)<br>	 pasul 1: [6, 48, 70, 80, 45, 13, 86, 58, 22]<br>	 pasul 2: [6, 13, 70, 80, 45, 48, 86, 58, 22]<br>	 pasul 3: [6, 13, 22, 80, 45, 48, 86, 58, 70]<br>	 pasul 4: [6, 13, 22, 45, 80, 48, 86, 58, 70]<br>	 pasul 5: [6, 13, 22, 45, 48, 80, 86, 58, 70]<br>	 pasul 6: [6, 13, 22, 45, 48, 58, 86, 80, 70]<br>	 pasul 7: [6, 13, 22, 45, 48, 58, 70, 80, 86]<br>	 pasul 8: [6, 13, 22, 45, 48, 58, 70, 80, 86]<br>	 pasul 9: [6, 13, 22, 45, 48, 58, 70, 80, 86]<br>Dupa Selection Sort, vectorul este sortat : [6, 13, 22, 45, 48, 58, 70, 80, 86]<br><br></pre><br><pre id="6" onclick="afisare(6)"><br><br>Problem9<br>9. Solutia problemei: <br>1. A/F ca [70, 94, 98, 22, 13, 76, 60, 81, 16, 32] rezulta din 2 pasi de Selection Sort (Maxim) : <br>94 > 70 => (FALS) <br><br> 2. A/F ca [70, 94, 98, 22, 13, 76, 60, 81, 16, 32] rezulta din 2 pasi de Insertion Sort : <br>94 > 70<br>(ADEVARAT) <br><br>3. A/F partitionat pentru Quicksort cu pivotul 98 <br>i. Pozitia pivotului = 3<br>ii. Vf. elementele de la stanga sunt mai mici <br>70 <= 98<br>94 <= 98<br>iii. Vf elementele de la dreapta mai mari<br>22 <= 98 => (FALS) <br><br>4. Exemplificam Bubble sort: <br>i.Vectorul are 10 elemente <br>ii.Cat timp facem interschimbari = > nu am terminat <br>0: [70, 94, 98, 22, 13, 76, 60, 81, 16, 32]<br>1: [70, 94, 22, 13, 76, 60, 81, 16, 32, 98]<br>2: [70, 22, 13, 76, 60, 81, 16, 32, 94, 98]<br>3: [22, 13, 70, 60, 76, 16, 32, 81, 94, 98]<br>4: [13, 22, 60, 70, 16, 32, 76, 81, 94, 98]<br>5: [13, 22, 60, 16, 32, 70, 76, 81, 94, 98]<br>6: [13, 22, 16, 32, 60, 70, 76, 81, 94, 98]<br>7: [13, 16, 22, 32, 60, 70, 76, 81, 94, 98]<br><br>5.Exemplificam Selection Sort(Maxim): <br>i.Vectorul are 10 elemente <br>0: [70, 94, 98, 22, 13, 76, 60, 81, 16, 32]<br>1: [98, 94, 70, 22, 13, 76, 60, 81, 16, 32]<br>2: [98, 94, 70, 22, 13, 76, 60, 81, 16, 32]<br>3: [98, 94, 81, 22, 13, 76, 60, 70, 16, 32]<br>4: [98, 94, 81, 76, 13, 22, 60, 70, 16, 32]<br>5: [98, 94, 81, 76, 70, 22, 60, 13, 16, 32]<br>6: [98, 94, 81, 76, 70, 60, 22, 13, 16, 32]<br>7: [98, 94, 81, 76, 70, 60, 32, 13, 16, 22]<br>8: [98, 94, 81, 76, 70, 60, 32, 22, 16, 13]<br>9: [98, 94, 81, 76, 70, 60, 32, 22, 16, 13]<br><br><br></pre><br><pre id="7" onclick="afisare(7)"><br><br>Problem10<br>Pentru toate cazurile generam submultimi de elemente din vector pentru a cauta-o pe aceea care <br>are numarul minim de elemente pe care sa le putem sterge pentru a satisface fiecare cerinta.<br>Generarea submultimilor se face prin selectia combinarilor de n elemente luate cate nrPasi <br>corespunzator subpunctului.<br>La fiecare pas din cerinta iteram prin combinarile genrate si le alegem pe cele care au o<br>lungime corespunzatoarenumarului de pasi pe care l-a facut altgoritmul si sunt sortate<br><br>a)Selectia maximului.<br><br>Pentru selectia maximului am gasit 11 subseturi de lungime 3 : [4, 5, 7] [4, 5, 6] [4, 5, 11] [4, 7, 11] [4, 6, 11] [5, 7, 11] [5, 6, 11] [0, 3, 6] [0, 3, 11] [0, 6, 11] [3, 6, 11] <br>Aceste subseturi au lungimea egala cu numarul de pasi(3) pentru acest subpunct, din cerinta.<br><br>La fiecare pas consideram secventa sortata  s1, ..., sP, unde P e lungimea secventei, si eliminam numerele:<br>	- care sunt mai mari decat sP<br>	- care sunt mai mici decat s1 si se afla dupa s1 in vector<br>	- care sunt mai mici decat sP si se afla dupa sP in vector<br>	- care apartin intervalului [s1, sP], dar nu sunt in secventa<br><br>Pentru secventa [4, 5, 7] elementele [ 8 0 3 6 11 1 ] au fost sterse conform celor de mai sus.<br>Pentru secventa [4, 5, 6] elementele [ 8 7 0 3 11 1 ] au fost sterse conform celor de mai sus.<br>...<br><br>RASPUNS: Secventa minima pe care o stergem este de lungime 5 => stergem: [8 0 3 6 1] <br><br>b)Selectia minimului:<br><br>Pentru selectia minimului am gasit 11 subseturi de lungime 3 : [4, 5, 7] [4, 5, 6] [4, 5, 11] [4, 7, 11] [4, 6, 11] [5, 7, 11] [5, 6, 11] [0, 3, 6] [0, 3, 11] [0, 6, 11] [3, 6, 11] <br>Aceste subseturi au lungimea egala cu numarul de pasi(3) pentru acest subpunct, din cerinta.<br><br>La fiecare pas consideram secventa sortata  s1, ..., sP, unde P e lungimea secventei, si eliminam numerele:<br>	- care sunt mai mici decat s1<br>	- care sunt mai mari decat sP si se afla la stanga lui sP<br>	- care apartin intervalului [s1, sP] dar nu se afla un subset<br><br>Pentru secventa [4, 5, 7] elementele [ 8 0 3 6 11 1 ] au fost sterse conform celor de mai sus.<br>Pentru secventa [4, 5, 6] elementele [ 8 7 0 3 11 1 ] au fost sterse conform celor de mai sus.<br>...<br><br>RASPUNS: Secventa minima pe care o stergem este de lungime 5 => stergem: [8 0 3 6 1] <br><br>c)Insertie:<br><br>Pentru insertie am gasit 3 subseturi care respecta cerinta : [4, 5, 7, 11] [4, 5, 6, 11] [0, 3, 6, 11] <br>Aceste subseturi au lungimea egala cu numarul de pasi+1(3+1=4) pentru acest subpunct, din cerinta.<br><br>La fiecare pas consideram secventa sortata  s1, ..., sP, unde P e lungimea secventei, si eliminam numerele:<br>	- care sunt mai mici decat s1<br>	- care sunt mai mari decat sP<br>	- care apartin intervalului [s1, sP] dar nu se afla un subset<br><br>Pentru secventa [4, 5, 7, 11] elementele [ 8 0 3 6 ] au fost sterse conform celor de mai sus.<br>Pentru secventa [4, 5, 6, 11] elementele [ 8 7 0 3 ] au fost sterse conform celor de mai sus.<br>...<br><br>RASPUNS: Secventa minima pe care o stergem este de lungime 4 => stergem: [8 0 3 6] <br></pre><br><pre id="8" onclick="afisare(8)"><br><br>Problem11<br>Idee de rezolvare:<br>Partitionarea Lomuto are ca scop alegerea unui element dintr-un vector de numere, care se va numi<br>pivot si modificarea pozitiilor elementelor din vector astfel incat, la finalul algoritmului,<br>elementele cu valoare mai mica decat pivotul se vor afla la stanga sa, iar cele mai mari decat<br>pivotul, in dreapta acestuia, pivotul ajungand pe pozitia in care ar sta daca am sorta vectorul.<br><br>Interschimbam 10 cu 41 iar i devine 0<br>Sirul devine:[10, 41, 55, 71, 78, 45, 40, 33]<br><br>Trecem la urmatorul element din sir.<br>Am ajuns la capatul sirului. In final, avem vectorul partitionat: [10, 33, 55, 71, 78, 45, 40, 41]<br></pre><br><pre id="9" onclick="afisare(9)"><br><br>Problem12<br>12. Idee de rezolvare: Construim vectorul tata asociat arborelui.<br><br>Parcurgem numerele date de la stanga la dreapta.<br>Primul numar din parcurgere este radacina si are tatal -1.<br>Tatal unui numar gasit pentru prima data este precedentul sau.<br>Daca elementul a mai fost intalnit trecem mai departe.<br><br>6 este radacina.<br>3 nevizitat => 6 = tatal <br>8 nevizitat => 3 = tatal <br>1 nevizitat => 8 = tatal <br>0 nevizitat => 1 = tatal <br>5 nevizitat => 0 = tatal <br>4 nevizitat => 1 = tatal <br>7 nevizitat => 1 = tatal <br>2 nevizitat => 8 = tatal <br><br>6<br>          3<br>                                        0<br>                                                  5<br><br>                              1<br><br>                                        4<br><br>                                        7<br><br>                              2<br><br>                    8<br><br>Vectorul de tati este [1, 8, 8, 6, 1, 0, -1, 1, 3]<br><br>Fii nodurilor sunt:<br>0 -> 5  <br>1 -> 0  4  7  <br>2 -> frunza<br>3 -> 8  <br>4 -> frunza<br>5 -> frunza<br>6 -> 3  <br>7 -> frunza<br>8 -> 1  2  <br><br></pre><br><pre id="10" onclick="afisare(10)"><br><br>Problem13<br>Idee de rezolvare: <br>Deoarece deja stim ca se cere un Arbore Binar de Cautare, fixam ultimul element din parcurgere ca fiind radacina si o impartim in doua intervale: <br>	-prima parte contine numere mai mici decat radacina si setul de elemente va merge in stanga acesteia <br>	-a doua parte contine numere mai mari decat radacina si setul de elemente va merge in dreapta acesteia <br>Repetam recursiv pentru fiecare interval.<br>Arborele construit este:<br><br><br>Nod: 43; Fiu stanga: 23<br>Nod: 23; Fiu stanga: 9; Fiu dreapta: 27<br>Nod: 9; Fiu dreapta: 11<br>Nod: 11<br>Nod: 27; Fiu stanga: 26; Fiu dreapta: 36<br>Nod: 26; Fiu stanga: 25<br>Nod: 25<br>Nod: 36<br><br>43 -------<br>|<br><br>                        36 -<br>                        |<br><br>                27 ---<br>                |<br><br>                        26 -<br>                        |<br><br>                                25 <br>                                |<br><br>        23 -----<br>        |<br><br>                        11 -<br>                        |<br><br>                9 ---<br>                |<br><br></pre><br><pre id="11" onclick="afisare(11)"><br><br>Problem13<br>Idee de rezolvare: <br>Deoarece deja stim ca se cere un Arbore Binar de Cautare, fixam ultimul element din parcurgere ca fiind radacina si o impartim in doua intervale: <br>	-prima parte contine numere mai mici decat radacina si setul de elemente va merge in stanga acesteia <br>	-a doua parte contine numere mai mari decat radacina si setul de elemente va merge in dreapta acesteia <br>Repetam recursiv pentru fiecare interval.<br>Arborele construit este:<br><br><br>Nod: 48; Fiu stanga: 22<br>Nod: 22; Fiu stanga: 2; Fiu dreapta: 44<br>Nod: 2; Fiu stanga: 0; Fiu dreapta: 8<br>Nod: 0<br>Nod: 8; Fiu dreapta: 12<br>Nod: 12; Fiu dreapta: 13<br>Nod: 13<br>Nod: 44; Fiu stanga: 30<br>Nod: 30<br><br>48 -------<br>|<br><br>                44 ---<br>                |<br><br>                        30 -<br>                        |<br><br>        22 -----<br>        |<br><br>                                        13 <br>                                        |<br><br>                                12 <br>                                |<br><br>                        8 -<br>                        |<br><br>                2 ---<br>                |<br><br>                        0 -<br>                        |<br><br></pre><br><pre id="12" onclick="afisare(12)"><br><br>Problem14<br>Idee de rezolvare:<br>Arborele binar de cautare se construieste pe principiul: un element mai mic decat tatal lui merge in stanga, iar elementul mai mare decat tatal lui merge in dreapta<br> Arborele binar de cautare construit pe baza secventei este:<br> ________47_____   <br>/               \  <br>7_           __59_ <br>  \         /     \<br> 16_____   49_   71<br>        \     \    <br>       44    57    <br>      /            <br>     34            <br>    /              <br>   18              <br><br>Parcurgere in postordine inseamna: elementul din stanga, elementul din dreapta,radacina<br> Parcurgerea in postordine este:[18, 34, 44, 16, 7, 57, 49, 71, 59, 47]<br></pre><br><pre id="13" onclick="afisare(13)"><br><br>Problem15<br>Idee de rezolvare: Pentru fiecare nod construim intai subarborele stang, apoi subarborele drept.<br>Arborele construit este: <br>Nod: 48 Fiu stanga: 2 <br>Nod: 2 Fiu stanga: 42 Fiu dreapta: 31 <br>Nod: 42 <br>Nod: 31 Fiu stanga: 0 Fiu dreapta: 10 <br>Nod: 0 <br>Nod: 10 <br><br>48 -------<br>|<br><br>                        10 -<br>                        |<br><br>                31 ---<br>                |<br><br>                        0 -<br>                        |<br><br>        2 -----<br>        |<br><br>                42 ---<br>                |<br><br></pre><br><pre id="14" onclick="afisare(14)"><br><br>Problem16<br><br><br>Idee de rezolvare:<br><br>Initial, avem vectorul v, indexul pivotului Ipiv si capetele vectorului: left si right.Primul pas este sa punem pivotul pe ultima pozitie prin interschimbare si sa se initieze numarul interschimbarilor cu 0.Parcurgem vectorul de la stanga la dreapta si cat timp valoarea elementului de pe pozitia j este egala cu valoarea pivotului, testam daca pozitia j este mai mica decat capatul din dreapta al vectorului, daca da, scad valoarea indicelui capatului de interval cu 1, interschimb valoarea curenta cu valoarea noului capat de interval cu indicele decrementat mai sus si valoarea lui nr se incrementeaza cu 1. Daca pozitia j este mai mare decat capatul din dreapta al vectorului, se trece la urmatorul element din vector dupa ce se testeaza pasul urmator. Testam daca valoarea curenta este mai mica decat cea a pivotului si daca da se interschimba valoarea curenta cu valoarea indicelui i+1, astfel toate numerele mai mici decat pivotul sunt plasate la inceputul vectorului.Valoarea i se opreste la ultimul element mai mic sau egal decat pivotul si mutam pivotul dupa valoarea din sir cu indicele i.Se parcurge sirul si se muta elementele mai mici sau egale cu pivotul inaintea pivotului si cele mai mari dupa el.Se muta elementele la inceputul vectorului pana la pozitia i+1. <br><br>Indexul pivotului este: 1<br><br>Inainte de mutarea elementelor egale cu pivotul:<br>[1, 4, 3, 3, 5, 3, 5, 0, 0, 0]<br>Pivootul si toate elementele egale cu pivotul sunt la sfarsitul sirului <br>Acum mutam pivotul si dublurile dupa ultimul element mai mic decat pivotul<br><br><br><br>Secventa finala este: 0 0 0 3 5 3 5 1 4 3 <br><br> Numarul de interschimbari este:5<br></pre><br><pre id="15" onclick="afisare(15)"><br><br>Problem17<br>Idee de rezolvare:<br>Folosim quicksort, numai ca atunci cand apelam recursiv, ne intrebam in ce parte fata de indexul pivotului se afla k si apelam numai in acea parte.<br><br>Sirul initial este:             [22, 14, 3, 9, 13, 5, 4, 21, 10, 15, 7]<br>Sirul dupa quicksort arata asa: [3, 4, 5, 7, 9, 10, 13, 14, 15, 21, 22]<br>K este egal cu 3=> v[3] = 5<br>Dupa algoritmul nostru, am gasit elementul:5<br><br></pre><br><pre id="16" onclick="afisare(16)"><br><br>Problem19<br>Heap-ul initial este [3, 30, 7, 48, 53, 86, 22, 80, 98, 58]<br>Scot elementul 3 din heap<br> [7, 30, 22, 48, 53, 86, 58, 80, 98] <br>Scot elementul 7 din heap<br> [22, 30, 58, 48, 53, 86, 98, 80] <br>Scot elementul 22 din heap<br> [30, 48, 58, 80, 53, 86, 98] <br>Scot elementul 30 din heap<br> [48, 53, 58, 80, 98, 86] <br>Scot elementul 48 din heap<br> [53, 80, 58, 86, 98] <br>Scot elementul 53 din heap<br> [58, 80, 98, 86] <br>Scot elementul 58 din heap<br> [80, 86, 98] <br>Scot elementul 80 din heap<br> [86, 98] <br>Scot elementul 86 din heap<br> [98] <br>Scot elementul 98 din heap<br> [] <br><br></pre><br><pre id="17" onclick="afisare(17)"><br><br>Problem22<br>============================================<br>	Rezolvare:<br>Idee de rezolvare: Permutam toate elementele din heap-ul initial, in afara de radacina, iar dupa aceea<br> am adaugat radacina la fiecare permutare si dupa am facut cate un min-heap.Apoi am memorat min-heap-ul<br> gasit, diferit de min-heap-ul initial si de toate min-heap-urile gasite precedent.<br> Min-heap initial : [2, 35, 49, 43, 59] <br>Alte min-heap-uri fata de cel initial:<br>[[2, 35, 43, 59, 49], [2, 35, 43, 49, 59]]<br></pre><br><pre id="18" onclick="afisare(18)"><br><br>Problem23<br>Ideea de rezolvare:<br>Aplicam shiftDown pentru nodurile de la [n/2,0] (in ordinea asta).<br>Shiftdown compara recursiv un nod i cu cei 2 copii si se interschimba<br>cu cel mai mic si aplicam algoritmul pana ajungem la o frunza.<br>Dupa pasul 1 sirul nostru arata astfel:<br>[7, 6, 10, 0, 11, 5, 2, 3, 8, 9, 1, 4]<br>Dupa pasul 2 sirul nostru arata astfel:<br>[7, 6, 10, 0, 11, 4, 2, 3, 8, 9, 1, 5]<br>Dupa pasul 3 sirul nostru arata astfel:<br>[7, 6, 10, 0, 1, 4, 2, 3, 8, 9, 11, 5]<br>Dupa pasul 4 sirul nostru arata astfel:<br>[7, 6, 10, 0, 1, 4, 2, 3, 8, 9, 11, 5]<br>Dupa pasul 5 sirul nostru arata astfel:<br>[7, 6, 2, 0, 1, 4, 10, 3, 8, 9, 11, 5]<br>Dupa pasul 6 sirul nostru arata astfel:<br>[7, 0, 2, 3, 1, 4, 10, 6, 8, 9, 11, 5]<br>Dupa pasul 7 sirul nostru arata astfel:<br>[0, 1, 2, 3, 7, 4, 10, 6, 8, 9, 11, 5]<br>In final vom obtine min-ansamblul: <br>[0, 1, 2, 3, 7, 4, 10, 6, 8, 9, 11, 5]<br>Complexitatea algoritmului este O(n).<br></pre><br><pre id="19" onclick="afisare(19)"><br><br>Problem25<br>3. Solutia problemei: <br>	0.Vectorul este: [21, 80, 58, 27, 89, 46, 91, 61, 28, 60]<br>	1.Adaugam noduri in heap: <br>		1.1 : [21]<br>		1.2 : [21, 80]<br>			80 >= 21 : Swap<br>		1.3 : [80, 21, 58]<br>		1.4 : [80, 21, 58, 27]<br>		1.5 : [80, 21, 58, 27, 89]<br>			89 >= 21 : Swap<br>			89 >= 80 : Swap<br>		1.6 : [89, 80, 58, 27, 21, 46]<br>		1.7 : [89, 80, 58, 27, 21, 46, 91]<br>			91 >= 80 : Swap<br>			91 >= 89 : Swap<br>		1.8 : [91, 89, 58, 27, 21, 46, 80, 61]<br>			61 >= 58 : Swap<br>		1.9 : [91, 89, 61, 27, 21, 46, 80, 58, 28]<br>		1.10 : [91, 89, 61, 27, 21, 46, 80, 58, 28, 60]<br>	2.Arborele in heap : [91, 89, 61, 27, 21, 46, 80, 58, 28, 60]<br>	3.Pentru decapitare interschimbam : 91 si 60<br>	4.Arborele decapitat [60, 89, 61, 27, 21, 46, 80, 58, 28]<br>		4.1 : 89 > 60 : [60, 89, 61, 27, 21, 46, 80, 58, 28]<br>		4.1 : 80 > 60 : [89, 60, 61, 27, 21, 46, 80, 58, 28]<br>	5.Arborele rearanjat [89, 80, 61, 27, 21, 46, 60, 58, 28]<br><br></pre><br><pre id="20" onclick="afisare(20)"><br><br>Problem28<br>Vectorul primit este: [4, 12, 0, 7, 5, 0, 2, 3, 1, 9, 11, 14, 17, 16, 0, 13, 0]<br>Vectorul sortat, fara 0, arata asa: [1, 2, 3, 4, 5, 7, 9, 11, 12, 13, 14, 16, 17]<br>Valoarea mediana trebuie sa fie: 9<br><br>min_heap este: [12]<br>max_heap este: [-4]<br>valoarea mediana este: 8.0<br><br>min_heap este: [7, 12]<br>max_heap este: [-5, -4]<br>valoarea mediana este: 6.0<br><br>min_heap este: [9, 11, 14, 12, 16, 17]<br>max_heap este: [-7, -4, -5, -1, -3, -2]<br>valoarea mediana este: 8.0<br><br>min_heap este: [9, 11, 13, 12, 16, 17, 14]<br>max_heap este: [-7, -4, -5, -1, -3, -2]<br>valoarea mediana este: 9<br><br><br></pre><br><pre id="21" onclick="afisare(21)"><br><br>Problem29<br>Idee de rezolvare:<br><br>Inseram intr-un vector v1 primele elemente mai mari decat 0 (daca primim un zero inainte, inseamna ca nu avem k elemente, deci le afisam pe toate).<br><br>Acum in acel vector v1 avem k elemente.<br><br>Continuam sa citim urmatoarele elemente intr-un vector v2. Cand primim 0, punem la gramada elemente lui v1 si ale lui v2 si aplicam statistici de ordine ca sa obtinem cele mai mari elemente din v1 si v2. Facem o partitionare quicksort cu un pivot ales la intamplare, si verificam daca pivotul este pe a k-a pozitie sau nu; daca k > pozitia, partitionam la stanga; daca k < pozitia, partitionam la dreapta; altfel, ne aflam pe pozitia k si acesta este numarul cautat.<br><br>Sirul dat : 33 89 31 16 59 34 36 0 76 0 12 0 90<br>k= 4<br><br>v1: 33 89 31 16<br>v2: 59 34 36<br>v: 33 89 31 16 59 34 36 => 16 33 31 34 89 59 36<br>Cele mai mari k elemente: 34 89 59 36<br><br>v1: 34 89 59 36<br>v2: 76<br>v: 34 89 59 36 76 => 34 36 59 76 89<br>Cele mai mari k elemente: 36 59 76 89<br><br>v1: 36 59 76 89<br>v2: 12<br>v: 36 59 76 89 12 => 12 36 59 76 89<br>Cele mai mari k elemente: 36 59 76 89<br><br><br></pre><br><pre id="22" onclick="afisare(22)"><br><br>Problem30<br>Idee de rezolvare: <br><br>Vom crea doua matrici, una care va contine numarul minim de insertii pe pozitia i,j pentru subsirul [i:j], iar cealalta care va contine palindromul creat prin numar minim de insertii pentru subsirul [i:j], pe pozitia i,j (doar deasupra diagonalei principale, matrici inferior triunghiulare).<br><br>Matricea cu numarul de insertii:<br>Parcurgem diagonalele paralele cu diagonala principala, si pentru subsirul [i:j] punem in matrice la pozitia i,j numarul minim de insertii necesar pentru a crea un palindrom.Luam capetele subsirului, le comparam: daca sunt egale, atunci nu avem nevoie de insertii, subsirul [i:j] are nevoie de tot atatea insertii ca subsirul [i+1:j-1]; in caz contrar, subsirul [i:j] are nevoie cu o insertie mai mult decat minimul dintre numarul de insertii necesar subsirului [i:j-1], respectiv [i+1:j]. <br><br>Matricea cu palindroame pentru orice subsir [i:j]:<br>Matricea e goala la inceput, cu exceptia diagonalei principale, care contine literele din sir. Parcurgem diagonalele paralele cu diagonala principala, si construim palindromul pentru subsirul [i:j], folosindu-ne de ce avem in stanga si dedesubt.<br><br>c cc ecce becceb bbeccebb <br>   c  ece  beceb   cebbec <br>        e    beb     ebbe <br>               b       bb <br>                        b <br><br>0 0 1 2 3 <br>0 0 1 2 2 <br>0 0 0 1 1 <br>0 0 0 0 0 <br>0 0 0 0 0 <br><br><br>Numarul minim de insertii este 3, iar palindromul rezultat este bbeccebb<br></pre><br><pre id="23" onclick="afisare(23)"><br><br>Problem31<br>31. Solutia problemei: <br>Idee de rezolvare: punem numerele din forma postfixata in stiva pana gasim un semn de operatie, apoi scoatem din stiva ultimele doua elemente.<br>Primul operand este al doilea numar scos. Facem operatia respectiva si punem rezultatul in stiva.<br>Repetam procedeul pana in stiva ramane un singur numar, acela fiind rezultatul expresiei.<br><br><table border=1><tr><td>6</td></tr></table><br><table border=1><tr><td>6</td><td>2</td></tr></table><br><table border=1><tr><td>6</td><td>2</td><td>3</td></tr></table><br>Am gasit semnul -<br><table border=1><tr><td>6</td><td><strike>2<strike></td><td><strike>3<strike></td></tr></table><br>Scoatem ultimele doua numere si punem in stiva rezultatul scaderii lor<br><table border=1><tr><td>6</td><td>-1</td><td>8</td></tr></table><br><table border=1><tr><td>6</td><td>-1</td><td>8</td><td>5</td></tr></table><br>Am gasit semnul -<br><table border=1><tr><td>6</td><td>-1</td><td><strike>8<strike></td><td><strike>5<strike></td></tr></table><br>Scoatem ultimele doua numere si punem in stiva rezultatul scaderii lor<br><table border=1><tr><td>6</td><td>-1</td><td>3</td><td>1</td></tr></table><br><table border=1><tr><td>6</td><td>-1</td><td>3</td><td>1</td><td>9</td></tr></table><br>Am gasit semnul +<br><table border=1><tr><td>6</td><td>-1</td><td>3</td><td><strike>1<strike></td><td><strike>9<strike></td></tr></table><br>Scoatem ultimele doua numere si punem in stiva rezultatul adunarii lor<br>Am gasit semnul -<br><table border=1><tr><td>6</td><td>-1</td><td><strike>3<strike></td><td><strike>10<strike></td></tr></table><br>Scoatem ultimele doua numere si punem in stiva rezultatul scaderii lor<br>Am gasit semnul *<br><table border=1><tr><td>6</td><td><strike>-1<strike></td><td><strike>-7<strike></td></tr></table><br>Scoatem ultimele doua numere si punem in stiva rezultatul inmultirii lor<br><table border=1><tr><td>6</td><td>7</td></tr></table><br>Am gasit semnul -<br><table border=1><tr><td><strike>6<strike></td><td><strike>7<strike></td></tr></table><br>Scoatem ultimele doua numere si punem in stiva rezultatul scaderii lor<br><br>                                        9<br>                              +<br>                                        1<br>                    -<br>                                        5<br>                              -<br>                                        8<br>          *<br>                              3<br>                    -<br>                              2<br>-<br>          6<br><br>Expresia este 6-((2-3)*((8-5)-(1+9)))<br>Rezultatul este -1<br></pre><br><pre id="24" onclick="afisare(24)"><br><br>Problem32<br>Parcurgem arborele incepand cu radacina pana gasim nodul cautat. De fiecare data cand ne mutam la un nod verificam daca este cel cautat. Altfel, decidem daca mergem la nodul din stanga, respectiv nodul din dreapta<br>		Nodul curent nu are valoarea 9<br>	> Numarul cautat 9 >= 5. Ne mutam la nodul din stanga<br>		Nodul curent nu are valoarea 9<br>	> Numarul cautat 9 >= 8. Ne mutam la nodul din dreapta<br>		Nodul curent nu are valoarea 9<br><br>Numarul 9 NU se afla in acest arbore<br><br></pre><br><pre id="25" onclick="afisare(25)"><br><br>problem33<br>Am ales nodul 24 pentru a dezechilibra arborele<br>Nu putem roti la dreapta nodul<br>Am ales nodul 95 pentru a dezechilibra arborele<br>Nu putem sa rotim la stanga nodul<br>Am ales nodul 73 pentru a dezechilibra arborele<br>Dupa rotatia la dreapta, arborele este:<br>R----32<br>     L----22<br>     |    L----7<br>     |    R----24<br>     R----73<br>          R----89<br>               R----95<br><br></pre><br><pre id="26" onclick="afisare(26)"><br><br>Problem37<br>a) Se construieste arborele:<br>Se iau caracterele cu ponderile cele mai mici:<br>N,9 si I,10<br>Si facem nodul ce are ca valoare "$" si suma ponderilor:$,19<br>Se aplica acelas procedeu in continuare, alegadu-se cele mai mici ponderi,dintre caracterele initiale, dar si noile noduri fomate<br>M,11 si T,12<br>Si facem nodul ce are ca valoare "$" si suma ponderilor:$,23<br>Se aplica acelas procedeu in continuare, alegadu-se cele mai mici ponderi,dintre caracterele initiale, dar si noile noduri fomate<br>P,13 si L,17<br>Si facem nodul ce are ca valoare "$" si suma ponderilor:$,30<br>Se aplica acelas procedeu in continuare, alegadu-se cele mai mici ponderi,dintre caracterele initiale, dar si noile noduri fomate<br>$,19 si A,22<br>Si facem nodul ce are ca valoare "$" si suma ponderilor:$,41<br>Se aplica acelas procedeu in continuare, alegadu-se cele mai mici ponderi,dintre caracterele initiale, dar si noile noduri fomate<br>$,23 si $,30<br>Si facem nodul ce are ca valoare "$" si suma ponderilor:$,53<br>Se aplica acelas procedeu in continuare, alegadu-se cele mai mici ponderi,dintre caracterele initiale, dar si noile noduri fomate<br>$,41 si $,53<br>Si facem nodul ce are ca valoare "$" si suma ponderilor:$,94<br>Se aplica acelas procedeu in continuare, alegadu-se cele mai mici ponderi,dintre caracterele initiale, dar si noile noduri fomate<br>Arborele final:<br>            ('L', 17)<br>        ('$', 30)<br>            ('P', 13)<br>    ('$', 53)<br>            ('T', 12)<br>        ('$', 23)<br>            ('M', 11)<br>('$', 94)<br>        ('A', 22)<br>    ('$', 41)<br>            ('I', 10)<br>        ('$', 19)<br>            ('N', 9)<br>Codarile literelor:<br>L:111<br>P:110<br>T:101<br>M:100<br>A:01<br>I:001<br>N:000<br><br>b)Care este codarea cuvantului: IMPLANTAT<br>['0110101101010100010101101', '0101000101100100010101101', '0011001101110100010101101', '1011011011110100010101101']<br>Solutia: 0011001101110100010101101<br><br>c) Decodati daca se poate:<br>Se parcurge arborele Huffman dupa "directiile" indicate de codare.<br>Daca urmand sirul nu ajungem la o litera din arbore, atunci sirul nu este o codare valida.<br>0010001010110011011101101: INTAMPLAT<br>0001000011100100010101101: NMIPANTAT<br>0111010000110011011101: APMIMPLA<br><br>d)<br>Cuvinte gasite:<br>AA AAA AI AL ALAI ALAIT ALAMAN ALAMA ALAMINA ALAN ALANINA ALA ALAMI ALAMIT ALAPTA ALAPTAT ALIA ALIANTA ALIAT ALIMAN ALIN ALINA ALINAT ALINI ALINIA ALINIAT ALINIT ALINT ALINTA ALINTAT ALIPI ALIPIT ALIT ALL ALLA ALMA ALPIN ALT ALTITA AMA AMAN AMANT AMANA AMANAT AMIANT AMIANTA AMIL AMIN AMINA AMINTI AMINTIT AN ANA ANAL ANIL ANILINA ANIMA ANIMA ANIMAL ANIMAT ANIN ANINA ANINAT ANTAL ANTANTA ANTA ANTI ANTIPAPA APATIT APA APLANA APLANAT APLIT APT APTIAN AT ATA ATAMAN ATATA ATLANT ATA ATATA ATATAT ATINTI ATINTIT ATIPI ATIPIT AL ALA ALALALT IA IAMA IAN IAPA IATA ILIMITAT IM IMAM IMAMAT IMAN IMITA IMITAT IMN IMPLANT IMPLANT IMPLANTA IMPLANTAT IN IN INANIMAT INAPT INIMA INIMA INITA INITIA INITIAL INITIAT INTIM INTIM INTIMA INTIMAT ITALIAN IT ITAN ITA ITI ITII ITIT II IMPAIA IMPAIAT IMPAMANTA IMPAMANTAT IMPANA IMPANAT IMPATIMA IMPATIMAT IMPATIMI IMPATIMIT IMPILA IMPILAT IMPLANTA IMPLANTAT IMPLINI IMPLINIT IN INAINTA INAINTAT INALT INALT INALTA INALTAT INMANA INMANAT INMII INMIIT INTAI INTALNI INTALNIT INTAMPINA INTAMPINAT INTAMPLA INTAMPLAT INTIMPINA INTIMPINAT INTINA INTINA INTINAT INTINA INTINAT LA LAI LAITA LAMA LAMA LAMANTIN LAMAT LAMA LAMINA LAMINAT LAMINA LAMPANT LAMPA LAN LANITAL LANTAN LANT LAPILI LAPIT LAPTI LAT LAT LATIN LAT LALAI LALAI LALAIT LALAIT LAMAI LAMAITA LAMPITA LAPAI LATI LATIT LANA LIANA LIANT LILA LILIAL LIMAN LIMAN LIMITA LIMITAT LIMITA LIN LIN LINIA LINIAT LINIAT LINT LINTITA LINTITA LINTITA LINTITA LINTI LIP LIPA LIPAN LIPAI LIPAI LIPAIT LIPI LIPIT LIPITAN LITINA LITA MAI MAIA MAIA MAIA MAIAL MAINA MAINAT MAL MALA MALIAN MALIN MALL MALM MALT MALTAT MAMA MAMITA MAMITA MANA MANI MANI MANIA MANIAT MANILA MANITA MANITAT MANITA MANTA MANTA MANTA MANTILA MAPA MAT MATA MATIMA MATINAL MATITA MAT MA MAI MALAI MALAI MALIN MAMITA MANA MANAT MATANAI MAL MALI MALIT MANA MANAT MANA MANIA MANIAT MAT MATAN MI MIA MIALA MILA MILITA MILITANT MILITIAN MIM MIM MIMA MIMANT MIMAT MIMA MINA MINAT MINA MINI MINIA MINIAT MINIM MINIM MINIMAL MINTAL MINTA MINTI MINTIT MIT MITA MITA NA NAI NALT NAMILA NAN NAP NAPALM NAT NATAL NAIMI NAIMIT NALTA NALTAT NAMI NAMIT NI NIT NIT PA PAI PAIA PAIANTA PAIATA PAL PAL PALAN PALAT PALAT PALATAL PALATIN PALATINAT PALATINAT PALATITA PALI PALI PALM PALMAT PALMA PALMITAT PALMITINA PALP PALPA PALPAT PALPIT PALPITA PALPITANT PALTIN PAMA PAMPA PAN PANAMA PANA PANTA PAP PAPA PAPAIA PAPAINA PAPAL PAPA PAPA PAPILA PAT PATALAMA PATA PATIMA PATINA PATINAT PATINA PAI PALAN PALALAI PALALAIT PALI PALIT PALMITA PAMANT PAPA PAPAT PATA PATAT PATIMI PATIMIT PATI PATI PATIT PAINITA PAL PALPAI PALPAIALA PALPAIT PAN PANA PI PIA PIAN PIANINA PIATA PII PIL PILA PILI PILIT PIMNITA PIN PINTA PIPA PIPA PIPAT PIPA PIPAI PIPAIALA PIPAIT PIPI PIPI PIPIT PITA PITI PITIT PLAI PLAN PLAN PLANA PLANAT PLANTA PLANTAT PLANTA PLAT PLATAN PLATAN PLATA PLATINA PLATINAT PLATINA PLATINIT PLAMAN PLATI PLATIT PLIA PLIANT PLIAT PLIN PLIN PLINI PLINIT PLINTA PLITA PTIALINA TA TAIN TAINA TAINITA TAL TALAN TALANT TALA TALAM TALI TALIAN TALIAN TALIM TALPA TALPINA TAMAN TANANA TANANT TANAT TANAT TANIN TANTAL TANTALIT TANTI TAPA TAPAT TAPA TAPITA TAPITAT TATA TAIA TAIAT TALANITA TALALAI TALPITA TAMAIA TAMAIAT TAMAITA TAPALAI TATAIT TATAN TATITA TAMP TAMPANA TAMPI TAMPINA TAMPIT TAMPLA TANT TIAMINA TII TIII TIMIN TIMP TIMP TIMPAN TIMPANITA TINA TIP TIP TIPA TIPTIL TITAN TITANIT TT TA TAL TAP TAPAP TAPIN TAPINA TATA TATA TATAI TATAIT TATANA TI TINTAT TINTA TINTI TINTIT TIPA TIPAT TIPAT TIPLA TIT <br></pre><br><pre id="27" onclick="afisare(27)"><br><br>Problem39<br>Lista simplu inlantuita este:<br><br>0:  39<br>1: <br>2: <br>3: <br>4: <br>5:  83<br>6:  19<br>7:  7<br>8:  8<br>9: <br>10: <br>11: <br>12: <br><br>linear probing:<br>0 : 39<br>1 :  <br>2 :  <br>3 :  <br>4 :  <br>5 : 83<br>6 : 19<br>7 : 7<br>8 : 8<br>9 :  <br>10 :  <br>11 :  <br>12 :  <br><br><br>quadratic probing:<br>0 :  <br>1 :  <br>2 :  <br>3 :  <br>4 :  <br>5 :  <br>6 : 19<br>7 : 39<br>8 :  <br>9 :  <br>10 : 83<br>11 :  <br>12 :  <br>13 : 7<br>14 : 8<br>15 :  <br>16 :  <br>17 :  <br>18 :  <br><br><br>double hashing:<br>0 : 7<br>1 : 8<br>2 :  <br>3 :  <br>4 : 39<br>5 : 19<br>6 : 83<br>7 :  <br>8 :  <br>9 :  <br>10 :  <br>11 :  <br>12 :  <br>13 :  <br>14 :  <br>15 :  <br>16 :  <br>17 :  <br>18 :  <br><br><br><br></pre><br><pre id="28" onclick="afisare(28)"><br><br>Problem40<br>Ideea de rezolvare:<br>Se primeste un hash si se testeaza o secventa de liste, astfel incat ordinea<br>in care ar fi putut fi inserate elemntele in hash sa poata genera o lista identica cu hash-ul.<br>Prin adresare elementele sunt puse intr-un tablou alocat static pe pozitiile cheilor lor, astfel incat<br>un element cu cheia k va fi memorat in locatia k.<br>Rezultat:[18, 15, 14, 6, 3, 8, 11, 13, 9, 7]<br></pre><br><pre id="29" onclick="afisare(29)"><br><br>Problem41<br>Idee de implemetare:<br>Algorimul lui Prim foloseste un min-Heap in care pune muchiile in functie de cost.<br>La primul pas considera nodul de start ca fiind solutia, adica arborele partial de cost minim.<br>Pentru a adauga noduri in arbore adaugam vecinii nodului de start intr-un heap in functie de cosul muchiei.<br>Ca sa adaugam muchia cu costul cel mai mic vom decapita heapul pentru a obtine muchia minima adiacenta la solutie.<br>Acum consideram solutia formata din cele doua noduri si punem in heap vecinii celui de-al doilea nod.<br>Repetam algoritmul pana cand vizitam toate nodurile din graf.<br>La final vom obtine arborele partial de cost minim.<br>Algoritm:<br>La pasul 1 am scos din heap (0, (0, -1)). Dupa stergere, heapul este: []<br><br>La pasul 2 am scos din heap (11, (3, 0)). Dupa stergere, heapul este: [(14, (6, 0)), (15, (2, 0))]<br><br>La pasul 3 am scos din heap (11, (0, 3)). Dupa stergere, heapul este: [(11, (4, 3)), (12, (5, 3)), (14, (6, 0)), (15, (2, 0))]<br><br>La pasul 4 am scos din heap (11, (4, 3)). Dupa stergere, heapul este: [(12, (5, 3)), (15, (2, 0)), (14, (6, 0))]<br><br>La pasul 5 am scos din heap (7, (2, 4)). Dupa stergere, heapul este: [(8, (6, 4)), (11, (3, 4)), (11, (5, 4)), (15, (2, 0)), (12, (5, 3)), (14, (6, 0))]<br><br>La pasul 6 am scos din heap (7, (4, 2)). Dupa stergere, heapul este: [(8, (6, 4)), (10, (1, 2)), (11, (5, 4)), (11, (3, 4)), (12, (5, 3)), (14, (6, 0)), (15, (0, 2)), (15, (2, 0))]<br><br>La pasul 7 am scos din heap (8, (6, 4)). Dupa stergere, heapul este: [(10, (1, 2)), (11, (3, 4)), (11, (5, 4)), (15, (2, 0)), (12, (5, 3)), (14, (6, 0)), (15, (0, 2))]<br><br>La pasul 8 am scos din heap (6, (5, 6)). Dupa stergere, heapul este: [(8, (4, 6)), (10, (1, 2)), (11, (5, 4)), (14, (0, 6)), (11, (3, 4)), (14, (6, 0)), (15, (0, 2)), (15, (2, 0)), (14, (1, 6)), (12, (5, 3))]<br><br>La pasul 9 am scos din heap (6, (6, 5)). Dupa stergere, heapul este: [(8, (4, 6)), (10, (1, 2)), (11, (4, 5)), (14, (0, 6)), (11, (3, 4)), (11, (5, 4)), (15, (0, 2)), (15, (2, 0)), (14, (1, 6)), (12, (5, 3)), (12, (3, 5)), (14, (6, 0))]<br><br>La pasul 10 am scos din heap (8, (4, 6)). Dupa stergere, heapul este: [(10, (1, 2)), (11, (3, 4)), (11, (4, 5)), (14, (0, 6)), (12, (3, 5)), (11, (5, 4)), (15, (0, 2)), (15, (2, 0)), (14, (1, 6)), (12, (5, 3)), (14, (6, 0))]<br><br>La pasul 11 am scos din heap (10, (1, 2)). Dupa stergere, heapul este: [(11, (3, 4)), (12, (3, 5)), (11, (4, 5)), (14, (0, 6)), (12, (5, 3)), (11, (5, 4)), (15, (0, 2)), (15, (2, 0)), (14, (1, 6)), (14, (6, 0))]<br><br>La pasul 12 am scos din heap (10, (2, 1)). Dupa stergere, heapul este: [(11, (3, 4)), (12, (3, 5)), (11, (4, 5)), (14, (0, 6)), (12, (5, 3)), (11, (5, 4)), (15, (0, 2)), (15, (2, 0)), (14, (1, 6)), (14, (6, 0)), (14, (6, 1))]<br><br>La pasul 13 am scos din heap (11, (3, 4)). Dupa stergere, heapul este: [(11, (4, 5)), (12, (3, 5)), (11, (5, 4)), (14, (0, 6)), (12, (5, 3)), (14, (6, 1)), (15, (0, 2)), (15, (2, 0)), (14, (1, 6)), (14, (6, 0))]<br><br>La pasul 14 am scos din heap (11, (4, 5)). Dupa stergere, heapul este: [(11, (5, 4)), (12, (3, 5)), (14, (6, 0)), (14, (0, 6)), (12, (5, 3)), (14, (6, 1)), (15, (0, 2)), (15, (2, 0)), (14, (1, 6))]<br><br>La pasul 15 am scos din heap (11, (5, 4)). Dupa stergere, heapul este: [(12, (3, 5)), (12, (5, 3)), (14, (6, 0)), (14, (0, 6)), (14, (1, 6)), (14, (6, 1)), (15, (0, 2)), (15, (2, 0))]<br><br>La pasul 16 am scos din heap (12, (3, 5)). Dupa stergere, heapul este: [(12, (5, 3)), (14, (0, 6)), (14, (6, 0)), (15, (2, 0)), (14, (1, 6)), (14, (6, 1)), (15, (0, 2))]<br><br>La pasul 17 am scos din heap (12, (5, 3)). Dupa stergere, heapul este: [(14, (0, 6)), (14, (1, 6)), (14, (6, 0)), (15, (2, 0)), (15, (0, 2)), (14, (6, 1))]<br><br>La pasul 18 am scos din heap (14, (0, 6)). Dupa stergere, heapul este: [(14, (1, 6)), (14, (6, 1)), (14, (6, 0)), (15, (2, 0)), (15, (0, 2))]<br><br>La pasul 19 am scos din heap (14, (1, 6)). Dupa stergere, heapul este: [(14, (6, 0)), (14, (6, 1)), (15, (0, 2)), (15, (2, 0))]<br><br>La pasul 20 am scos din heap (14, (6, 0)). Dupa stergere, heapul este: [(14, (6, 1)), (15, (2, 0)), (15, (0, 2))]<br><br>La pasul 21 am scos din heap (14, (6, 1)). Dupa stergere, heapul este: [(15, (0, 2)), (15, (2, 0))]<br><br>La pasul 22 am scos din heap (15, (0, 2)). Dupa stergere, heapul este: [(15, (2, 0))]<br><br>La pasul 23 am scos din heap (15, (2, 0)). Dupa stergere, heapul este: []<br><br><br>################################################################################<br>Rezultat:<br>Arborele partial reprezentat prin vectorul de tati este:<br>[-1, 2, 4, 0, 3, 6, 4]<img src="/static/solutii/Lab212/ArboreProblem41Var3.png"><br></pre><br><pre id="30" onclick="afisare(30)"><br><br>Problem42<br>Idee de rezolvare: <br>Pas 1: Sortam muchiile crescator in functie de cost;<br>pas 2: Alegem cea mai mica muchie. Verificam daca inchide un ciclu cu arborele<br>format pana acum. Daca nu inchide un ciclu, includem muchia in arborele de cost minim;<br>Pas 3: Repetam pasul 2 pana cand numarul muchiilor din arbore este cu unu mai putin decat numarul de noduri.<br><br>Muchiile arborelui de cost minim obtinut sunt urmatoarele:<br>1 -- 5 == 3<br>0 -- 3 == 5<br>3 -- 6 == 7<br>4 -- 6 == 15<br>0 -- 5 == 16<br>2 -- 3 == 25<br><img src="/static/solutii/Lab212/APMProblem42Var3.png"><br></pre><br><pre id="31" onclick="afisare(31)"><br><br>Problem43<br><br>Idee de rezolvare:<br>Construim un dictionar pentru distante si atribuim infinit tuturor nodurilor, cu exceptia nodului de start, care va primi 0<br>Construim un heap in care adaugam initial nodul de start cu distanta 0. <br>Calculam distantele de la nodul de start la toti vecinii sai, pe care ii adaugam in heap, cu distantele respective.<br>Extragem din heap nodul cu distanta cea mai mica si verificam daca distantele de la nodul de start prin<br>acest nod sunt mai mici decat ceea ce aveam deja, caz in care actualizam dictionarul de distante si adaugam<br>in heap nodurile si distantele corespunzatoare.<br>Repetam ultimul pas cat timp heap-ul e nevid<br><br>Extragem din heap 0 A<br>Adaugam in heap 13 B<br>Actualizam distantele: {'A': 0, 'B': 13, 'C': inf, 'D': inf, 'E': inf, 'F': inf}<br>Adaugam in heap 8 F<br>Actualizam distantele: {'A': 0, 'B': 13, 'C': inf, 'D': inf, 'E': inf, 'F': 8}<br>Extragem din heap 8 F<br>Adaugam in heap 9 C<br>Actualizam distantele: {'A': 0, 'B': 13, 'C': 9, 'D': inf, 'E': inf, 'F': 8}<br>Extragem din heap 9 C<br>Adaugam in heap 21 D<br>Actualizam distantele: {'A': 0, 'B': 13, 'C': 9, 'D': 21, 'E': inf, 'F': 8}<br>Extragem din heap 13 B<br>Extragem din heap 21 D<br>Adaugam in heap 29 E<br>Actualizam distantele: {'A': 0, 'B': 13, 'C': 9, 'D': 21, 'E': 29, 'F': 8}<br>Extragem din heap 29 E<br>Distanta minima de la nodul A catre oricare alt nod din graf este: <br>{'A': 0, 'B': 13, 'C': 9, 'D': 21, 'E': 29, 'F': 8}<br>Nodul anterior fiecarui nod este:<br>{'A': 'A', 'B': 'A', 'C': 'F', 'D': 'C', 'E': 'D', 'F': 'A'}<img src="/static/solutii/Lab212/graf43Problem43Var3.png"><br></pre>