<pre id="0" onclick="afisare(0)"><br><br>Problem1<br><br>    Creeam cele trei structuri de date in ordine: stiva coada stiva.<br>Stiva1:|__________|<br>Coada:|__________|<br>Stiva2:|__________|<br><br>   Efectuam sirul de operatii: <br>M ̲c a ̲c r ̲c i ̲c u ̲c s ̲c v ̲c  ̲1  ̲2 a ̲c  ̲1  ̲2 c ̲c  ̲1  ̲2 a ̲c  ̲1  ̲2 n ̲c  ̲1  ̲2 t ̲c  ̲1  ̲2 a ̲c  ̲1  ̲2 a ̲c  ̲1 r ̲c  ̲1 e ̲c  ̲1 <br><br>   Obtinem: <br>Stiva1: M    a    r    i    u    s    v̶    a̶    c̶    a̶    n̶    t̶    a̶    a̶    r̶    e̶<br>Coada:  v̶    a̶    c̶    a̶    n̶    t̶    a̶    a    r    e<br>Stiva2: v    a    c    a    n    t    a<br><br></pre><br><pre id="1" onclick="afisare(1)"><br><br>Problem4<br> Avand elementele 1 10 6 intr-o stiva (6 este ultimul el. inserat), gasiti o succesiune de mutari a.i. sa stergeti el. 6 din stiva avand la dispozitie 2 cozi si operatiile:<br>P -> se extrage un el. din stiva, se introduce in prima coada<br>S -> se sterge un el. din stiva<br>1 -> se extrage un el. din coada 1 se introduce in coada 2<br>2 -> se extrage un el. din coada 2 se introduce in coada 1<br>I_1 -> se extrage un el din coada 1 si se introduce in stiva<br>I_2 -> se extrage un el din coada 2 si se introduce in stiva<br><br>-------- Rezolvare --------<br><br>Avem initial:<br>	Stiva		1 10 6 (varf)<br>	Coada 1		Coada este goala.<br><br>	Coada 2		Coada este goala.<br><br>___________________________________________<br><br>Elementul de scos se afla in varful stivei,deci vom aplica operatia S 6<br><br>	Stiva		1 10 (varf)<br>	Coada 1		Coada este goala.<br><br>	Coada 2		Coada este goala.<br><br></pre><br><pre id="2" onclick="afisare(2)"><br><br>Problem5<br>  <br>Introducem elementele: [5, 2, 3, 1, 8, 6, 7] intr-un arbore binar de cautare. <br>Radacina va fi: 5<br><br>Vectorul de tati este: [-1, 2, 5, 2, -1, 0, 8, 6, 5, -1]<br>Vectorul de nivel este: [-1, 2, 1, 2, -1, 0, 2, 3, 1, -1]<br><br>Verificam in vectorul de tati ce noduri pot fi sterse in 2 moduri (cele care au 2 fii).<br>Nodurile care se pot sterge in doua moduri sunt: <br>2 deoarece are 2 fii<br>5 deoarece are 2 fii<br><br>Arborele initial este:<br><br><br>          8<br>                              7<br>                    6<br>5<br>                    3<br>          2<br>                    1<br><br>Arborele final, dupa stergerea elementului 1 este:<br><br><br>          8<br>                              7<br>                    6<br>5<br>                    3<br>          2<br><br><br></pre><br><pre id="3" onclick="afisare(3)"><br><br>Problem8<br>Subpuctul a)<br>INSERTION SORT: <br><br>PASUL 1:<br>[48, 58, 69, 13, 47, 56, 72]<br><br>PASUL 2:<br>[48, 58, 69, 13, 47, 56, 72]<br><br>PASUL 3:<br>[48, 58, 13, 69, 47, 56, 72]<br>[48, 13, 58, 69, 47, 56, 72]<br>[13, 48, 58, 69, 47, 56, 72]<br>[13, 48, 58, 69, 47, 56, 72]<br><br>BUBBLE SORT: <br><br>PASUL 1:<br>[13, 47, 48, 56, 58, 69, 72]<br>PASUL 2:<br>[13, 47, 48, 56, 58, 69, 72]<br>PASUL 3:<br>[13, 47, 48, 56, 58, 69, 72]<br>PASUL 4:<br>[13, 47, 48, 56, 58, 69, 72]<br>Subpunctul b)<br>SELECTIA MAXIMULUI:<br> PASUL 1:<br>[48, 58, 69, 13, 47, 56, 72]:<br> PASUL 2:<br>[48, 58, 69, 13, 47, 56, 72]:<br> PASUL 3:<br>[48, 58, 69, 13, 47, 56, 72]:<br> PASUL 4:<br>[48, 58, 69, 13, 47, 56, 72]:<br>SELECTIA MINIMULUI:<br><br> PASUL 1:<br>[13, 58, 69, 48, 47, 56, 72]<br> PASUL 2:<br>[13, 47, 69, 48, 58, 56, 72]<br> PASUL 3:<br>[13, 47, 48, 69, 58, 56, 72]<br>Subpunctul c)<br><br>Pivot: 58<br>[48, 56, 47, 13, 58, 69, 72]<br><br>Pivot: 13<br>[13, 56, 47, 48, 58, 69, 72]<br><br>Pivot: 56<br>[13, 48, 47, 56, 58, 69, 72]<br><br>Pivot: 47<br>[13, 47, 48, 56, 58, 69, 72]<br><br>Folosim partitionarea Hoare<br><br>Subpunctul d)<br>INSERTION SORT:<br>PASUL 1:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>PASUL 2:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>PASUL 3:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>PASUL 4:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>PASUL 5:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>PASUL 6:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>PASUL 7:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>SELECTION SORT: <br><br>PASUL 1:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>PASUL 2:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>PASUL 3:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>PASUL 4:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>PASUL 5:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>PASUL 6:<br>[13, 47, 48, 56, 58, 69, 72]<br><br>PASUL 7:<br>[13, 47, 48, 56, 58, 69, 72]<br><br></pre><br><pre id="4" onclick="afisare(4)"><br><br>Problem9<br>nesortat = 49, 88, 74, 71, 39, 58, 7, 57, 94, 99<br>sortat = 7, 39, 49, 57, 58, 71, 74, 88, 94, 99<br><br>Vectorul a rezultat in urma aplicarii a 1 pasi din Selection Sort (maxim) ?<br>Adevarat, deoarece dupa aplicarea a 1 pasi din selection sort (maxim) cele mai mari 1 numere se vor afla la finalul vectorului<br><br>Vectorul a rezultat in urma aplicarii a 2 pasi din Insertion Sort ?<br>Adevarat, deoarece ultimii 3 termeni ai vectorului sunt sortati ! (termenii sortati la sfarsit)<br><br>Verificati daca vectorul a rezultat in urma unei partitionari folosind pivotul 94 !<br>Aflam pozitia pe care se afla pivotul: 8<br>Verificam daca elementele din stanga sunt mai mici decat pivotul, iar cele din dreapta, mai mari. <br>Da, vectorul a rezultat in urma unei partitionari folosind pivotul 94<br><br>Sortare cu Bubble Sort:<br>Sirul este: 49, 88, 74, 71, 39, 58, 7, 57, 94, 99<br>Dupa parcurgere sirul este: 49, 74, 71, 39, 58, 7, 57, 88, 94, 99<br>Dupa parcurgere sirul este: 49, 71, 39, 58, 7, 57, 74, 88, 94, 99<br>Dupa parcurgere sirul este: 49, 39, 58, 7, 57, 71, 74, 88, 94, 99<br>Dupa parcurgere sirul este: 39, 49, 7, 57, 58, 71, 74, 88, 94, 99<br>Dupa parcurgere sirul este: 39, 7, 49, 57, 58, 71, 74, 88, 94, 99<br>Dupa parcurgere sirul este: 7, 39, 49, 57, 58, 71, 74, 88, 94, 99<br>Dupa parcurgere sirul este: 7, 39, 49, 57, 58, 71, 74, 88, 94, 99<br>La aceasta parcurgere nu se face nici o inversare !<br>Sirul este sortat !<br>v = 7, 39, 49, 57, 58, 71, 74, 88, 94, 99<br><br>Sortare cu Selection Sort (maxim):<br>Sirul este: 49, 88, 74, 71, 39, 58, 7, 57, 94, 99<br>Parcurgem sirul pana la elementul 99 si nu se face nicio interschimbare . <br>Sirul este: 49, 88, 74, 71, 39, 58, 7, 57, 94, 99<br>Parcurgem sirul pana la elementul 94 si nu se face nicio interschimbare . <br>Sirul este: 49, 88, 74, 71, 39, 58, 7, 57, 94, 99<br>Parcurgem sirul pana la elementul 57 si interschimbam 57 cu 88 .<br>Sirul este: 49, 57, 74, 71, 39, 58, 7, 88, 94, 99<br>Parcurgem sirul pana la elementul 7 si interschimbam 7 cu 74 .<br>Sirul este: 49, 57, 7, 71, 39, 58, 74, 88, 94, 99<br>Parcurgem sirul pana la elementul 58 si interschimbam 58 cu 71 .<br>Sirul este: 49, 57, 7, 58, 39, 71, 74, 88, 94, 99<br>Parcurgem sirul pana la elementul 39 si interschimbam 39 cu 58 .<br>Sirul este: 49, 57, 7, 39, 58, 71, 74, 88, 94, 99<br>Parcurgem sirul pana la elementul 39 si interschimbam 39 cu 57 .<br>Sirul este: 49, 39, 7, 57, 58, 71, 74, 88, 94, 99<br>Parcurgem sirul pana la elementul 7 si interschimbam 7 cu 49 .<br>Sirul este: 7, 39, 49, 57, 58, 71, 74, 88, 94, 99<br>Parcurgem sirul pana la elementul 39 si nu se face nicio interschimbare . <br>Sirul este sortat !<br>v = 7, 39, 49, 57, 58, 71, 74, 88, 94, 99<br><br><br></pre><br><pre id="5" onclick="afisare(5)"><br><br>Problem10<br><br>Generam toate combinarile posibile cu elementele vectorului,pana cand am rezolvat toate cerintele. Pentru fiecare combinare generata sterg din vector respectivele elemente si verific daca satisface vreuna din cerinte.<br> <br>---Numarul minim de elemente care trebuiesc sterse pt ca vectorul sa fie rezultatul a 1 pasi de sortare prin selectia maximului este 0<br>   Vectorul rezultat dupa stergeri este [91, 86, 83, 29, 22, 74, 43, 46, 96]<br>   CONDITIA INDEPLINITA: pe ultimele 1 pozitii se afla cele mai mari elemente din vector, sortate crescator<br>---Pentru a satisface 2 pasi de sortare prin insertie directa, numarul minim de elemente care trebuiesc sterse este 5 ({74, 83, 86, 91, 29}).<br>   Vectorul rezultat dupa stergeri este [22, 43, 46, 96]<br>   CONDITIA INDEPLINITA: primele 3 elemente din vector sunt sortate crescator<br>---Pentru a satisface 2 pasi de sortare prin selectia minumului, numarul minim de elemente care trebuiesc sterse este 5 ({74, 83, 86, 91, 29}).<br>   Vectorul rezultat dupa stergeri este [22, 43, 46, 96]<br>   CONDITIA INDEPLINITA: pe primele 2 pozitii se afla cele mai mici elemente din vector, sortate crescator<br></pre><br><pre id="6" onclick="afisare(6)"><br><br>Problem11<br>O partitionare a vectorului este:<br>[0, 5, 4, 1, 2, 4, 6, 93, 48, 96, 66]<br><br><br>Pivotul este : 6<br>Vrem ca pivotul sa se afle pe ultima pozitie in sir<br>Daca nu se afla pe ultima pozitie atunci il interschimbam cu elementul aflat pe pozitia respectiva<br>Dupa interschimbarea pivotului sirul devine : [0, 48, 5, 4, 1, 96, 66, 93, 2, 4, 6]<br><br>Vom calcula pozitia unde trebuie sa stea pivotul,crescand indicele si efectuand interschimbari a.i. elementele mai mici sau egale sa fie in stanga sa.<br>La sfarsit pivotul va fi mutat pe pozitia corespunzatoare.<br>Pozitia pivotului este initial -1 dar va deveni cel putin 0 pe parcursul algoritmului.<br><br>Pasul 1 : Elementul 0 este mai mic decat pivotul ---> se interschimba 0 cu 0 iar pozitia pivotului devine 0<br>Vectorul la aces pas al algoritmului este : [0, 48, 5, 4, 1, 96, 66, 93, 2, 4, 6]<br><br>Pasul 2 : Elementul 48 este mai mare decat pivotul ---> vectorul si pozitia pivotului raman aceleasi<br>Vectorul la aces pas al algoritmului este : [0, 48, 5, 4, 1, 96, 66, 93, 2, 4, 6]<br><br>Pasul 3 : Elementul 5 este mai mic decat pivotul ---> se interschimba 5 cu 48 iar pozitia pivotului devine 1<br>Vectorul la aces pas al algoritmului este : [0, 5, 48, 4, 1, 96, 66, 93, 2, 4, 6]<br><br>Pasul 4 : Elementul 4 este mai mic decat pivotul ---> se interschimba 4 cu 48 iar pozitia pivotului devine 2<br>Vectorul la aces pas al algoritmului este : [0, 5, 4, 48, 1, 96, 66, 93, 2, 4, 6]<br><br>Pasul 5 : Elementul 1 este mai mic decat pivotul ---> se interschimba 1 cu 48 iar pozitia pivotului devine 3<br>Vectorul la aces pas al algoritmului este : [0, 5, 4, 1, 48, 96, 66, 93, 2, 4, 6]<br><br>Pasul 6 : Elementul 96 este mai mare decat pivotul ---> vectorul si pozitia pivotului raman aceleasi<br>Vectorul la aces pas al algoritmului este : [0, 5, 4, 1, 48, 96, 66, 93, 2, 4, 6]<br><br>Pasul 7 : Elementul 66 este mai mare decat pivotul ---> vectorul si pozitia pivotului raman aceleasi<br>Vectorul la aces pas al algoritmului este : [0, 5, 4, 1, 48, 96, 66, 93, 2, 4, 6]<br><br>Pasul 8 : Elementul 93 este mai mare decat pivotul ---> vectorul si pozitia pivotului raman aceleasi<br>Vectorul la aces pas al algoritmului este : [0, 5, 4, 1, 48, 96, 66, 93, 2, 4, 6]<br><br>Pasul 9 : Elementul 2 este mai mic decat pivotul ---> se interschimba 2 cu 48 iar pozitia pivotului devine 4<br>Vectorul la aces pas al algoritmului este : [0, 5, 4, 1, 2, 96, 66, 93, 48, 4, 6]<br><br>Pasul 10 : Elementul 4 este mai mic decat pivotul ---> se interschimba 4 cu 96 iar pozitia pivotului devine 5<br>Vectorul la aces pas al algoritmului este : [0, 5, 4, 1, 2, 4, 66, 93, 48, 96, 6]<br><br>Pasul 11 : Elementul 6 este egal cu pivotul ---> se interschimba 6 cu 66 iar pozitia pivotului devine 6<br>Vectorul la aces pas al algoritmului este : [0, 5, 4, 1, 2, 4, 6, 93, 48, 96, 66]<br><br><br><br></pre><br><pre id="7" onclick="afisare(7)"><br><br>Problem12<br><br>Reconstruim arborele plecand de la parcurgerea data<br>Pentru fiecare nou voi afisa fii lui<br>3<br>|---------6<br><br>6<br>|---------8<br>|---------12<br><br>8<br>|---------4<br>|---------9<br><br>9<br>|---------2<br><br>4<br>|---------5<br><br>12<br>|---------1<br>|---------7<br>|---------10<br><br>1<br>|---------11<br><br></pre><br><pre id="8" onclick="afisare(8)"><br><br>Problema13<br><br>Radacina arborelui este 13<br>Parcurgerea in inordine (SRD) a arborelui este: [9, 13, 14, 15, 16, 18, 19]<br><br>Arborele reconstruit din SDR+SRD este: <br><br>                              19<br>                    18<br>          16<br>                    15<br>                              14<br>13<br>          9<br></pre><br><pre id="9" onclick="afisare(9)"><br><br>Problem14<br><br>pentru a:[2, 4, 3, 16, 12, 11, 10, 17, 18, 9] afiseaza: DA<br><br>Arborele este:<br><br><br>          18<br>                    17<br>                                                            16<br>                                                  12<br>                                        11<br>                              10<br>9<br>                    4<br>          3<br>                    2<br><br>pentru b:[3, 2, 5, 11, 8, 7, 16, 18, 15, 4] afiseaza: DA<br><br>Arborele este:<br><br><br>                    18<br>                              16<br>          15<br>                                        11<br>                              8<br>                    7<br>                              5<br>4<br>                    3<br>          2<br><br>pentru c:[4, 8, 20, 10, 5, 3, 15, 16, 13, 19] afiseaza: NU, deoarece, 10 < 19, iar 10 este pe pozitia 3, cand ar fi trebuit sa fie pozitionat inainte de numarul 20 care se afla pe pozitia 2.<br><br></pre><br><pre id="10" onclick="afisare(10)"><br><br>Problem15<br>0. Numerele sortate: [5, 27, 43, 46, 59, 64, 75]<br></pre><br><pre id="11" onclick="afisare(11)"><br><br>Problem17<br>Cautam elementul de pe pozitia 1.<br>Aplicam quick sort modificat.<br><br> Am ales random pivotul: 96<br> Vectorul dupa partitionarea cu pivotul 96 arata asa: <br>[26, 24, 25, 61, 6, 66, 88, 71, 32, 96]<br><br> Am ales random pivotul: 66<br> Vectorul dupa partitionarea cu pivotul 66 arata asa: <br>[26, 24, 25, 61, 6, 32, 66, 71, 88, 96]<br><br> Am ales random pivotul: 24<br> Vectorul dupa partitionarea cu pivotul 24 arata asa: <br>[6, 24, 25, 61, 26, 32, 66, 71, 88, 96]<br> Am gasit elementul de pe pozitia 1, acesta este 6.<br> <br></pre><br><pre id="12" onclick="afisare(12)"><br><br>Problem24<br>Idee de rezolvare: Cream un MIN_heap. Avem radacina a + b * sqrt(k) si inseram in heap numerele (a + 1) + b * sqrt(k) si a + (b + 1) * sqrt(k). <br>Dupa fiecare inserare reechilibram heap-ul. Afisam radacina, decapitam heap-ul si il reechilibram.<br><br>Heap:  ( 0 , 0 ) ,  ( 1 , 0 ) ,  ( 0 , 1 ) <br>Primul element este: 0<br><br>Heap:  ( 1 , 0 ) ,  ( 0 , 1 ) ,  ( 2 , 0 ) ,  ( 1 , 1 ) <br>Al 2-lea element este: 1 + 0 * sqrt(5) = 1.0 <br><br>Heap:  ( 2 , 0 ) ,  ( 0 , 1 ) ,  ( 1 , 1 ) ,  ( 3 , 0 ) ,  ( 2 , 1 ) <br>Al 3-lea element este: 2 + 0 * sqrt(5) = 2.0 <br><br>Heap:  ( 0 , 1 ) ,  ( 3 , 0 ) ,  ( 1 , 1 ) ,  ( 2 , 1 ) ,  ( 0 , 2 ) <br>Al 4-lea element este: 0 + 1 * sqrt(5) = 2.23606797749979 <br><br>Heap:  ( 3 , 0 ) ,  ( 4 , 0 ) ,  ( 1 , 1 ) ,  ( 0 , 2 ) ,  ( 2 , 1 ) ,  ( 3 , 1 ) <br>Al 5-lea element este: 3 + 0 * sqrt(5) = 3.0 <br><br>Heap:  ( 1 , 1 ) ,  ( 4 , 0 ) ,  ( 3 , 1 ) ,  ( 0 , 2 ) ,  ( 2 , 1 ) ,  ( 1 , 2 ) <br>Al 6-lea element este: 1 + 1 * sqrt(5) = 3.23606797749979 <br><br>Heap:  ( 4 , 0 ) ,  ( 2 , 1 ) ,  ( 5 , 0 ) ,  ( 0 , 2 ) ,  ( 1 , 2 ) ,  ( 3 , 1 ) ,  ( 4 , 1 ) <br>Al 7-lea element este: 4 + 0 * sqrt(5) = 4.0 <br><br>Heap:  ( 2 , 1 ) ,  ( 0 , 2 ) ,  ( 5 , 0 ) ,  ( 4 , 1 ) ,  ( 1 , 2 ) ,  ( 3 , 1 ) ,  ( 2 , 2 ) <br>Al 8-lea element este: 2 + 1 * sqrt(5) = 4.23606797749979 <br><br>Heap:  ( 0 , 2 ) ,  ( 1 , 2 ) ,  ( 5 , 0 ) ,  ( 4 , 1 ) ,  ( 2 , 2 ) ,  ( 3 , 1 ) ,  ( 0 , 3 ) <br>Al 9-lea element este: 0 + 2 * sqrt(5) = 4.47213595499958 <br><br>Heap:  ( 5 , 0 ) ,  ( 1 , 2 ) ,  ( 3 , 1 ) ,  ( 4 , 1 ) ,  ( 2 , 2 ) ,  ( 0 , 3 ) ,  ( 6 , 0 ) ,  ( 5 , 1 ) <br>Al 10-lea element este: 5 + 0 * sqrt(5) = 5.0 <br><br>Heap:  ( 3 , 1 ) ,  ( 1 , 2 ) ,  ( 6 , 0 ) ,  ( 4 , 1 ) ,  ( 2 , 2 ) ,  ( 0 , 3 ) ,  ( 5 , 1 ) ,  ( 3 , 2 ) <br>Al 11-lea element este: 3 + 1 * sqrt(5) = 5.23606797749979 <br><br>Heap:  ( 1 , 2 ) ,  ( 4 , 1 ) ,  ( 6 , 0 ) ,  ( 3 , 2 ) ,  ( 2 , 2 ) ,  ( 0 , 3 ) ,  ( 5 , 1 ) ,  ( 1 , 3 ) <br>Al 12-lea element este: 1 + 2 * sqrt(5) = 5.47213595499958 <br><br>Heap:  ( 6 , 0 ) ,  ( 4 , 1 ) ,  ( 0 , 3 ) ,  ( 7 , 0 ) ,  ( 2 , 2 ) ,  ( 1 , 3 ) ,  ( 5 , 1 ) ,  ( 3 , 2 ) ,  ( 6 , 1 ) <br>Al 13-lea element este: 6 + 0 * sqrt(5) = 6.0 <br><br>Heap:  ( 4 , 1 ) ,  ( 2 , 2 ) ,  ( 0 , 3 ) ,  ( 7 , 0 ) ,  ( 6 , 1 ) ,  ( 1 , 3 ) ,  ( 5 , 1 ) ,  ( 3 , 2 ) ,  ( 4 , 2 ) <br>Al 14-lea element este: 4 + 1 * sqrt(5) = 6.23606797749979 <br><br>Heap:  ( 2 , 2 ) ,  ( 7 , 0 ) ,  ( 0 , 3 ) ,  ( 3 , 2 ) ,  ( 6 , 1 ) ,  ( 1 , 3 ) ,  ( 5 , 1 ) ,  ( 4 , 2 ) ,  ( 2 , 3 ) <br>Al 15-lea element este: 2 + 2 * sqrt(5) = 6.47213595499958 <br><br></pre><br><pre id="13" onclick="afisare(13)"><br><br>Problem28<br>	Cream heap-urile: <br><br>Vectorul initial: [49, 8, 17, 28, 44, 40, 11, 0]<br>Min heap: [40, 49, 44]<br>  40<br>49  44<br>Max heap: [28, 11, 17, 8]<br>      28<br>  11      17<br>8<br>Mediana 1 este: 28<br><br>Vectorul initial: [49, 8, 17, 28, 44, 40, 11, 0, 34, 32, 3, 23, 18, 30, 0]<br>Min heap: [28, 34, 30, 49, 40, 44, 32]<br>      28<br>  34      30<br>49  40  44  32<br>Max heap: [23, 11, 18, 8, 3, 17]<br>      23<br>  11      18<br>8  3  17<br>Mediana 2 este: 28<br><br>Vectorul initial: [49, 8, 17, 28, 44, 40, 11, 0, 34, 32, 3, 23, 18, 30, 0, 12, 20, 42, 35, 0]<br>Min heap: [28, 34, 30, 35, 40, 44, 32, 49, 42]<br>              28<br>      34              30<br>  35      40      44      32<br>49  42<br>Max heap: [23, 20, 18, 11, 3, 17, 12, 8]<br>              23<br>      20              18<br>  11      3      17      12<br>8<br>Mediana 3 este: 28<br><br><br></pre><br><pre id="14" onclick="afisare(14)"><br><br>Problem29<br><br>22, 23, 38<br>22, 23, 35<br>8, 22, 23<br><br></pre>