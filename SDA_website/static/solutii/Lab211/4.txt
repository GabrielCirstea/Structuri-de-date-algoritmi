<pre id="0" onclick="afisare(0)"><br><br>Problem1<br><br>    Creeam cele trei structuri de date in ordine: stiva coada stiva.<br>Stiva1:|__________|<br>Coada:|__________|<br>Stiva2:|__________|<br><br>   Efectuam sirul de operatii: <br>G ̲c e ̲c o ̲c r ̲c g ̲c e ̲c b ̲c  ̲1  ̲2 a ̲c  ̲1  ̲2 n ̲c  ̲1  ̲2 a ̲c  ̲1  ̲2 n ̲c  ̲1  ̲2 e ̲c  ̲1  ̲2 v ̲c  ̲1 r ̲c  ̲1 e ̲c  ̲1 a ̲c  ̲1 <br><br>   Obtinem: <br>Stiva1: G    e    o    r    g    e    b̶    a̶    n̶    a̶    n̶    e̶    v̶    r̶    e̶    a̶<br>Coada:  b̶    a̶    n̶    a̶    n̶    e̶    v    r    e    a<br>Stiva2: b    a    n    a    n    e<br><br></pre><br><pre id="1" onclick="afisare(1)"><br><br>Problem4<br> Avand elementele 1 intr-o stiva (1 este ultimul el. inserat), gasiti o succesiune de mutari a.i. sa stergeti el. 1 din stiva avand la dispozitie 2 cozi si operatiile:<br>P -> se extrage un el. din stiva, se introduce in prima coada<br>S -> se sterge un el. din stiva<br>1 -> se extrage un el. din coada 1 se introduce in coada 2<br>2 -> se extrage un el. din coada 2 se introduce in coada 1<br>I_1 -> se extrage un el din coada 1 si se introduce in stiva<br>I_2 -> se extrage un el din coada 2 si se introduce in stiva<br><br>-------- Rezolvare --------<br><br>Avem initial:<br>	Stiva		1 (varf)<br>	Coada 1		Coada este goala.<br><br>	Coada 2		Coada este goala.<br><br>___________________________________________<br><br>Elementul de scos se afla in varful stivei,deci vom aplica operatia S 1<br><br>	Stiva		Stiva este goala.<br><br>	Coada 1		Coada este goala.<br><br>	Coada 2		Coada este goala.<br><br></pre><br><pre id="2" onclick="afisare(2)"><br><br>Problem5<br>  <br>Introducem elementele: [2, 7, 8, 1, 6, 4, 3] intr-un arbore binar de cautare. <br>Radacina va fi: 2<br><br>Vectorul de tati este: [-1, 2, 0, 4, 6, -1, 7, 2, 7, -1]<br>Vectorul de nivel este: [-1, 1, 0, 4, 3, -1, 2, 1, 2, -1]<br><br>Verificam in vectorul de tati ce noduri pot fi sterse in 2 moduri (cele care au 2 fii).<br>Nodurile care se pot sterge in doua moduri sunt: <br>2 deoarece are 2 fii<br>7 deoarece are 2 fii<br><br>Arborele initial este:<br><br><br>                    8<br>          7<br>                    6<br>                              4<br>                                        3<br>2<br>          1<br><br>Arborele final, dupa stergerea elementului 1 este:<br><br><br>                    8<br>          7<br>                    6<br>                              4<br>                                        3<br>2<br><br><br></pre><br><pre id="3" onclick="afisare(3)"><br><br>Problem8<br>Subpuctul a)<br>INSERTION SORT: <br><br>PASUL 1:<br>[49, 54, 75, 43, 94, 63, 28]<br>[49, 54, 75, 43, 94, 63, 28]<br><br>PASUL 2:<br>[49, 54, 75, 43, 94, 63, 28]<br><br>PASUL 3:<br>[49, 54, 43, 75, 94, 63, 28]<br>[49, 43, 54, 75, 94, 63, 28]<br>[43, 49, 54, 75, 94, 63, 28]<br>[43, 49, 54, 75, 94, 63, 28]<br><br>BUBBLE SORT: <br><br>PASUL 1:<br>[28, 43, 49, 54, 63, 75, 94]<br>PASUL 2:<br>[28, 43, 49, 54, 63, 75, 94]<br>PASUL 3:<br>[28, 43, 49, 54, 63, 75, 94]<br>PASUL 4:<br>[28, 43, 49, 54, 63, 75, 94]<br>Subpunctul b)<br>SELECTIA MAXIMULUI:<br> PASUL 1:<br>[54, 49, 75, 43, 94, 63, 28]:<br> PASUL 2:<br>[54, 49, 75, 43, 94, 63, 28]:<br> PASUL 3:<br>[54, 49, 75, 43, 94, 63, 28]:<br> PASUL 4:<br>[54, 49, 75, 43, 94, 63, 28]:<br>SELECTIA MINIMULUI:<br><br> PASUL 1:<br>[28, 49, 75, 43, 94, 63, 54]<br> PASUL 2:<br>[28, 43, 75, 49, 94, 63, 54]<br> PASUL 3:<br>[28, 43, 49, 75, 94, 63, 54]<br> PASUL 4:<br>[28, 43, 49, 54, 94, 63, 75]<br>Subpunctul c)<br><br>Pivot: 75<br>[54, 49, 28, 43, 63, 75, 94]<br><br>Pivot: 28<br>[28, 49, 54, 43, 63, 75, 94]<br><br>Pivot: 43<br>[28, 43, 54, 49, 63, 75, 94]<br><br>Pivot: 54<br>[28, 43, 49, 54, 63, 75, 94]<br><br>Folosim partitionarea Hoare<br><br>Subpunctul d)<br>INSERTION SORT:<br>PASUL 1:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>PASUL 2:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>PASUL 3:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>PASUL 4:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>PASUL 5:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>PASUL 6:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>PASUL 7:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>SELECTION SORT: <br><br>PASUL 1:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>PASUL 2:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>PASUL 3:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>PASUL 4:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>PASUL 5:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>PASUL 6:<br>[28, 43, 49, 54, 63, 75, 94]<br><br>PASUL 7:<br>[28, 43, 49, 54, 63, 75, 94]<br><br></pre><br><pre id="4" onclick="afisare(4)"><br><br>Problem9<br>nesortat = 46, 21, 13, 38, 52, 53, 72<br>sortat = 13, 21, 38, 46, 52, 53, 72<br><br>Vectorul a rezultat in urma aplicarii a 1 pasi din Selection Sort (maxim) ?<br>Adevarat, deoarece dupa aplicarea a 1 pasi din selection sort (maxim) cele mai mari 1 numere se vor afla la finalul vectorului<br><br>Vectorul a rezultat in urma aplicarii a 2 pasi din Insertion Sort ?<br>Adevarat, deoarece ultimii 3 termeni ai vectorului sunt sortati ! (termenii sortati la sfarsit)<br><br>Verificati daca vectorul a rezultat in urma unei partitionari folosind pivotul 53 !<br>Aflam pozitia pe care se afla pivotul: 5<br>Verificam daca elementele din stanga sunt mai mici decat pivotul, iar cele din dreapta, mai mari. <br>Da, vectorul a rezultat in urma unei partitionari folosind pivotul 53<br><br>Sortare cu Bubble Sort:<br>Sirul este: 46, 21, 13, 38, 52, 53, 72<br>Dupa parcurgere sirul este: 21, 13, 38, 46, 52, 53, 72<br>Dupa parcurgere sirul este: 13, 21, 38, 46, 52, 53, 72<br>Dupa parcurgere sirul este: 13, 21, 38, 46, 52, 53, 72<br>La aceasta parcurgere nu se face nici o inversare !<br>Sirul este sortat !<br>v = 13, 21, 38, 46, 52, 53, 72<br><br>Sortare cu Selection Sort (maxim):<br>Sirul este: 46, 21, 13, 38, 52, 53, 72<br>Parcurgem sirul pana la elementul 72 si nu se face nicio interschimbare . <br>Sirul este: 46, 21, 13, 38, 52, 53, 72<br>Parcurgem sirul pana la elementul 53 si nu se face nicio interschimbare . <br>Sirul este: 46, 21, 13, 38, 52, 53, 72<br>Parcurgem sirul pana la elementul 52 si nu se face nicio interschimbare . <br>Sirul este: 46, 21, 13, 38, 52, 53, 72<br>Parcurgem sirul pana la elementul 38 si interschimbam 38 cu 46 .<br>Sirul este: 38, 21, 13, 46, 52, 53, 72<br>Parcurgem sirul pana la elementul 13 si interschimbam 13 cu 38 .<br>Sirul este: 13, 21, 38, 46, 52, 53, 72<br>Parcurgem sirul pana la elementul 21 si nu se face nicio interschimbare . <br>Sirul este sortat !<br>v = 13, 21, 38, 46, 52, 53, 72<br><br><br></pre><br><pre id="5" onclick="afisare(5)"><br><br>Problem10<br><br>Generam toate combinarile posibile cu elementele vectorului,pana cand am rezolvat toate cerintele. Pentru fiecare combinare generata sterg din vector respectivele elemente si verific daca satisface vreuna din cerinte.<br> <br>---Pentru a satisface 1 pasi de sortare prin insertie directa, numarul minim de elemente care trebuiesc sterse este 1 ({35}).<br>   Vectorul rezultat dupa stergeri este [14, 84, 15, 85, 100, 23]<br>   CONDITIA INDEPLINITA: primele 2 elemente din vector sunt sortate crescator<br>---Pentru a satisface 3 pasi de sortare prin selectia maximului, numarul minim de elemente care trebuiesc sterse este 2 ({23, 15}).<br>   Vectorul rezultat dupa stergeri este [35, 14, 84, 85, 100]<br>   CONDITIA INDEPLINITA: pe ultimele 3 pozitii se afla cele mai mari elemente din vector, sortate crescator<br>---Pentru a satisface 3 pasi de sortare prin selectia minumului, numarul minim de elemente care trebuiesc sterse este 3 ({35, 84, 23}).<br>   Vectorul rezultat dupa stergeri este [14, 15, 85, 100]<br>   CONDITIA INDEPLINITA: pe primele 3 pozitii se afla cele mai mici elemente din vector, sortate crescator<br></pre><br><pre id="6" onclick="afisare(6)"><br><br>Problem11<br>O partitionare a vectorului este:<br>[6, 6, 13, 14, 15, 26, 77, 43, 53, 35, 36]<br><br><br>Pivotul este : 26<br>Vrem ca pivotul sa se afle pe ultima pozitie in sir<br>Daca nu se afla pe ultima pozitie atunci il interschimbam cu elementul aflat pe pozitia respectiva<br>Dupa interschimbarea pivotului sirul devine : [6, 53, 35, 6, 13, 36, 77, 43, 14, 15, 26]<br><br>Vom calcula pozitia unde trebuie sa stea pivotul,crescand indicele si efectuand interschimbari a.i. elementele mai mici sau egale sa fie in stanga sa.<br>La sfarsit pivotul va fi mutat pe pozitia corespunzatoare.<br>Pozitia pivotului este initial -1 dar va deveni cel putin 0 pe parcursul algoritmului.<br><br>Pasul 1 : Elementul 6 este mai mic decat pivotul ---> se interschimba 6 cu 6 iar pozitia pivotului devine 0<br>Vectorul la aces pas al algoritmului este : [6, 53, 35, 6, 13, 36, 77, 43, 14, 15, 26]<br><br>Pasul 2 : Elementul 53 este mai mare decat pivotul ---> vectorul si pozitia pivotului raman aceleasi<br>Vectorul la aces pas al algoritmului este : [6, 53, 35, 6, 13, 36, 77, 43, 14, 15, 26]<br><br>Pasul 3 : Elementul 35 este mai mare decat pivotul ---> vectorul si pozitia pivotului raman aceleasi<br>Vectorul la aces pas al algoritmului este : [6, 53, 35, 6, 13, 36, 77, 43, 14, 15, 26]<br><br>Pasul 4 : Elementul 6 este mai mic decat pivotul ---> se interschimba 6 cu 53 iar pozitia pivotului devine 1<br>Vectorul la aces pas al algoritmului este : [6, 6, 35, 53, 13, 36, 77, 43, 14, 15, 26]<br><br>Pasul 5 : Elementul 13 este mai mic decat pivotul ---> se interschimba 13 cu 35 iar pozitia pivotului devine 2<br>Vectorul la aces pas al algoritmului este : [6, 6, 13, 53, 35, 36, 77, 43, 14, 15, 26]<br><br>Pasul 6 : Elementul 36 este mai mare decat pivotul ---> vectorul si pozitia pivotului raman aceleasi<br>Vectorul la aces pas al algoritmului este : [6, 6, 13, 53, 35, 36, 77, 43, 14, 15, 26]<br><br>Pasul 7 : Elementul 77 este mai mare decat pivotul ---> vectorul si pozitia pivotului raman aceleasi<br>Vectorul la aces pas al algoritmului este : [6, 6, 13, 53, 35, 36, 77, 43, 14, 15, 26]<br><br>Pasul 8 : Elementul 43 este mai mare decat pivotul ---> vectorul si pozitia pivotului raman aceleasi<br>Vectorul la aces pas al algoritmului este : [6, 6, 13, 53, 35, 36, 77, 43, 14, 15, 26]<br><br>Pasul 9 : Elementul 14 este mai mic decat pivotul ---> se interschimba 14 cu 53 iar pozitia pivotului devine 3<br>Vectorul la aces pas al algoritmului este : [6, 6, 13, 14, 35, 36, 77, 43, 53, 15, 26]<br><br>Pasul 10 : Elementul 15 este mai mic decat pivotul ---> se interschimba 15 cu 35 iar pozitia pivotului devine 4<br>Vectorul la aces pas al algoritmului este : [6, 6, 13, 14, 15, 36, 77, 43, 53, 35, 26]<br><br>Pasul 11 : Elementul 26 este egal cu pivotul ---> se interschimba 26 cu 36 iar pozitia pivotului devine 5<br>Vectorul la aces pas al algoritmului este : [6, 6, 13, 14, 15, 26, 77, 43, 53, 35, 36]<br><br><br><br></pre><br><pre id="7" onclick="afisare(7)"><br><br>Problem12<br><br>Reconstruim arborele plecand de la parcurgerea data<br>Pentru fiecare nou voi afisa fii lui<br>5<br>|---------1<br>|---------8<br><br>1<br>|---------9<br><br>9<br>|---------6<br><br>8<br>|---------3<br>|---------4<br>|---------7<br>|---------10<br><br>10<br>|---------2<br><br></pre><br><pre id="8" onclick="afisare(8)"><br><br>Problema13<br><br>Radacina arborelui este 16<br>Parcurgerea in inordine (SRD) a arborelui este: [5, 6, 10, 11, 15, 16, 19]<br><br>Arborele reconstruit din SDR+SRD este: <br><br>          19<br>16<br>          15<br>                    11<br>                                        10<br>                              6<br>                                        5<br></pre><br><pre id="9" onclick="afisare(9)"><br><br>Problem14<br><br>pentru a:[5, 3, 2, 9, 8, 17, 16, 19, 18, 14] afiseaza: DA<br><br>Arborele este:<br><br><br>                    19<br>          18<br>                              17<br>                    16<br>14<br>                    9<br>          8<br>                                        5<br>                              3<br>                    2<br><br>pentru b:[2, 4, 11, 19, 8, 3, 18, 16, 15, 13] afiseaza: NU, deoarece, 8 < 13, iar 8 este pe pozitia 4, cand ar fi trebuit sa fie pozitionat inainte de 19 care se afla pe pozitia 3.<br>pentru c:[4, 3, 11, 10, 16, 13, 7, 18, 19, 17] afiseaza: DA<br><br>Arborele este:<br><br><br>          19<br>                    18<br>17<br>                              16<br>                    13<br>                                        11<br>                              10<br>          7<br>                              4<br>                    3<br><br><br></pre><br><pre id="10" onclick="afisare(10)"><br><br>Problem15<br>0. Numerele sortate: [30, 34, 44, 55, 61, 64, 80, 96]<br></pre><br><pre id="11" onclick="afisare(11)"><br><br>Problem17<br>Cautam elementul de pe pozitia 3.<br>Aplicam quick sort modificat.<br><br> Am ales random pivotul: 19<br> Vectorul dupa partitionarea cu pivotul 19 arata asa: <br>[5, 3, 12, 19, 31, 92, 42, 63, 37, 58, 36, 60, 70, 74, 43]<br><br> Am ales random pivotul: 3<br> Vectorul dupa partitionarea cu pivotul 3 arata asa: <br>[3, 5, 12, 19, 31, 92, 42, 63, 37, 58, 36, 60, 70, 74, 43]<br><br> Am ales random pivotul: 5<br> Vectorul dupa partitionarea cu pivotul 5 arata asa: <br>[3, 5, 12, 19, 31, 92, 42, 63, 37, 58, 36, 60, 70, 74, 43]<br> Am gasit elementul de pe pozitia 3, acesta este 12.<br> <br></pre><br><pre id="12" onclick="afisare(12)"><br><br>Problem24<br>Idee de rezolvare: Cream un MIN_heap. Avem radacina a + b * sqrt(k) si inseram in heap numerele (a + 1) + b * sqrt(k) si a + (b + 1) * sqrt(k). <br>Dupa fiecare inserare reechilibram heap-ul. Afisam radacina, decapitam heap-ul si il reechilibram.<br><br>Heap:  ( 0 , 0 ) ,  ( 1 , 0 ) ,  ( 0 , 1 ) <br>Primul element este: 0<br><br>Heap:  ( 1 , 0 ) ,  ( 0 , 1 ) ,  ( 2 , 0 ) ,  ( 1 , 1 ) <br>Al 2-lea element este: 1 + 0 * sqrt(2) = 1.0 <br><br>Heap:  ( 0 , 1 ) ,  ( 1 , 1 ) ,  ( 2 , 0 ) ,  ( 0 , 2 ) <br>Al 3-lea element este: 0 + 1 * sqrt(2) = 1.4142135623730951 <br><br>Heap:  ( 2 , 0 ) ,  ( 1 , 1 ) ,  ( 0 , 2 ) ,  ( 3 , 0 ) ,  ( 2 , 1 ) <br>Al 4-lea element este: 2 + 0 * sqrt(2) = 2.0 <br><br>Heap:  ( 1 , 1 ) ,  ( 3 , 0 ) ,  ( 0 , 2 ) ,  ( 2 , 1 ) ,  ( 1 , 2 ) <br>Al 5-lea element este: 1 + 1 * sqrt(2) = 2.414213562373095 <br><br>Heap:  ( 0 , 2 ) ,  ( 3 , 0 ) ,  ( 1 , 2 ) ,  ( 2 , 1 ) ,  ( 0 , 3 ) <br>Al 6-lea element este: 0 + 2 * sqrt(2) = 2.8284271247461903 <br><br>Heap:  ( 3 , 0 ) ,  ( 2 , 1 ) ,  ( 1 , 2 ) ,  ( 0 , 3 ) ,  ( 4 , 0 ) ,  ( 3 , 1 ) <br>Al 7-lea element este: 3 + 0 * sqrt(2) = 3.0 <br><br>Heap:  ( 2 , 1 ) ,  ( 4 , 0 ) ,  ( 1 , 2 ) ,  ( 0 , 3 ) ,  ( 3 , 1 ) ,  ( 2 , 2 ) <br>Al 8-lea element este: 2 + 1 * sqrt(2) = 3.414213562373095 <br><br>Heap:  ( 1 , 2 ) ,  ( 4 , 0 ) ,  ( 2 , 2 ) ,  ( 0 , 3 ) ,  ( 3 , 1 ) ,  ( 1 , 3 ) <br>Al 9-lea element este: 1 + 2 * sqrt(2) = 3.8284271247461903 <br><br>Heap:  ( 4 , 0 ) ,  ( 0 , 3 ) ,  ( 2 , 2 ) ,  ( 1 , 3 ) ,  ( 3 , 1 ) ,  ( 5 , 0 ) ,  ( 4 , 1 ) <br>Al 10-lea element este: 4 + 0 * sqrt(2) = 4.0 <br><br>Heap:  ( 0 , 3 ) ,  ( 3 , 1 ) ,  ( 2 , 2 ) ,  ( 1 , 3 ) ,  ( 4 , 1 ) ,  ( 5 , 0 ) ,  ( 0 , 4 ) <br>Al 11-lea element este: 0 + 3 * sqrt(2) = 4.242640687119286 <br><br></pre><br><pre id="13" onclick="afisare(13)"><br><br>Problem28<br>	Cream heap-urile: <br><br>Vectorul initial: [15, 6, 38, 31, 18, 0]<br>Min heap: [18, 38, 31]<br>  18<br>38  31<br>Max heap: [15, 6]<br>  15<br>6<br>Mediana 1 este: 18<br><br>Vectorul initial: [15, 6, 38, 31, 18, 0, 9, 5, 34, 22, 17, 11, 4, 29, 12, 43, 49, 0]<br>Min heap: [18, 22, 29, 38, 34, 31, 49, 43]<br>              18<br>      22              29<br>  38      34      31      49<br>43<br>Max heap: [17, 15, 12, 6, 4, 9, 11, 5]<br>              17<br>      15              12<br>  6      4      9      11<br>5<br>Mediana 2 este: 17.5<br><br>Vectorul initial: [15, 6, 38, 31, 18, 0, 9, 5, 34, 22, 17, 11, 4, 29, 12, 43, 49, 0, 39, 0]<br>Min heap: [18, 22, 29, 38, 34, 31, 49, 43, 39]<br>              18<br>      22              29<br>  38      34      31      49<br>43  39<br>Max heap: [17, 15, 12, 6, 4, 9, 11, 5]<br>              17<br>      15              12<br>  6      4      9      11<br>5<br>Mediana 3 este: 18<br><br><br></pre><br><pre id="14" onclick="afisare(14)"><br><br>Problem29<br><br>5, 29<br><br></pre>